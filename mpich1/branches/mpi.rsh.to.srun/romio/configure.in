# -*- Mode: shell-script -*-
# build with
# autoconf --localdir=../confdb configure.in
# (or wherever the confdb is)
#
AC_PREREQ(2.59)

# if this blows up, it's because you forgot to run autoheader
AC_INIT(adio/include/romioconf.h.in)
# VERSION=1.2.6
# AC_MSG_RESULT([Configuring ROMIO Version $VERSION])
CONFIGURE_ARGS="$*"
if test -n "$CONFIGURE_ARGS" ; then
    echo "Configuring with args $CONFIGURE_ARGS"
fi

AC_CONFIG_HEADER(adio/include/romioconf.h)

dnl
NOF77=0
NOF90=0
ARCH=""
arch_IRIX=""
MPI=""
MPI_INCLUDE_DIR=""
ROMIO_INCLUDE=""
TEST_LIBNAME=""
FILE_SYSTEM=""
# Do not set variables to empty that may be communicated from the
# outside environment (e.g., MPI_LIB, MPI_BIN_DIR, LIBNAME)
DEBUG=no
MIPS=0
BITS=0
FROM_MPICH=${FROM_MPICH:-no}
FROM_MPICH2=${FROM_MPICH2:-no}
if test "$FROM_MPICH" = yes -a "$FROM_MPICH2" = yes ; then
    AC_MSG_WARN([Both FROM_MPICH and FROM_MPICH set to yes; at most one should  be yes])
    
fi
FROM_LAM=${FROM_LAM:-no}
if test "$FROM_LAM" = 1 ; then FROM_LAM=yes ; fi
CFLAGS=${CFLAGS:-""}
LL="lld"
AR_LOCAL=""
DEFINE_HAVE_MPI_GREQUEST="#undef HAVE_MPI_GREQUEST"
HAVE_MPI_INFO=""
BUILD_MPI_INFO=""
MPI_FINFO1=""
MPI_FINFO2=""
MPI_FINFO3=""
MPI_FINFO4=""
MPI_FARRAY1=""
MPI_FARRAY2=""
MPI_FARRAY3=""
MPI_FARRAY4=""
MPI_FARRAY5=""
MPI_FARRAY6=""
MPI_FARRAY7=""
DEFS=""
ROMIO_LFLAGS=""
ROMIO_LIBLIST=""
ROMIO_TCFLAGS=""
ROMIO_TCPPFLAGS=""
ROMIO_TFFLAGS=""
NOPROFILE=0
MPIRUN=""
FORTRAN_TEST=""
MAKE=${MAKE:-"make"}
# foll. needed for f77 test programs
F77GETARG="call getarg(i,str)"
F77IARGC="iargc()"
F77MPIOINC=""
FTESTDEFINE=""
FORTRAN_MPI_OFFSET=""
MPIOF_H_INCLUDED=0
MPI_OFFSET_KIND1="!"
MPI_OFFSET_KIND2="!"
TEST_CC=""
TEST_F77=""
TRY_WEAK_SYMBOLS=1
#
# Error handlers (not used with MPICH2, which provides its own routines)
MPIO_EXTRA_OBJECTS="get_errh.o set_errh.o"
MPIO_EXTRA_TMP_POBJECTS="get_errh.p set_errh.p"
MPIO_EXTRA_REAL_POBJECTS="_get_errh.o _set_errh.o"
#
# Completion routines for MPIO_Requests.  MPI Implementations with
# generalized requests do not need these
# ioreq_c2f and ioreq_f2c are not MPIO_Requests; rather, they 
MPIO_REQOBJECTS="iotest.o iotestall.o iotestany.o iotestsome.o iowait.o iowaitall.o iowaitany.o iowaitsome.o ioreq_c2f.o ioreq_f2c.o"
MPIO_REQ_TMP_POBJECTS="iotest.p iowait.p iowaitall.p iowaitany.p iotestall.p iotestany.p iowaitsome.p iotestsome.p"
MPIO_REQ_REAL_POBJECTS="_iotest.o _iowait.o _iowaitall.o _iowaitany.o _iotestall.o _iotestany.o _iowaitsome.o _iotestsome.o"
#
have_aio=no
#
known_filesystems="nfs ufs pfs pvfs pvfs2 testfs xfs panfs gridftp"
known_mpi_impls="mpich2_mpi mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi"
#
# Defaults
AC_ARG_ENABLE(aio,[
--enable-aio - Request use of asynchronous I/O routines (default)],
[ 
  if test "x$enableval" = "xno" ; then
    disable_aio=yes
  else
    disable_aio=no
  fi
], disable_aio=no)
AC_ARG_ENABLE(echo, 
[--enable-echo  - Turn on strong echoing. The default is enable=no.] ,set -x)
AC_ARG_ENABLE(f77,
[--enable-f77 - Turn on support for Fortran 77 (default)],,enable_f77=yes)
AC_ARG_ENABLE(f90,
[--enable-f90 - Turn on support for Fortran 90 (default)],,enable_f90=yes)
AC_ARG_ENABLE(weak-symbols,
[--enable-weak-symbols - Turn on support for weak symbols],,enable_weak_symbols=yes)
AC_ARG_ENABLE(debug,
[--enable-debug - Build a debugging version],,)
AC_ARG_WITH(file-system,[
--with-file-system=name - Build with support for the named file systems],,)
AC_ARG_WITH(mpi,[
--with-mpi=name - Specify MPI implementation to build ROMIO for],,)
dnl
if test "$enable_f77" != "yes" ; then
   NOF77=1
fi
if test "$enable_f90" != "yes" ; then
   NOF90=1
fi
if test "$enable_debug" = "yes" ; then
    DEBUG=yes
fi
if test "$enable_weak_symbols" = "no" ; then
    TRY_WEAK_SYMBOLS=0
fi
MPI=$with_mpi
FILE_SYSTEM=$with_file_system
#
dnl AC_CONFIG_AUX_DIR(../../../confdb)
dnl Set the directory that contains the required install-sh, config.sub,
dnl and config.guess .  Make sure that these are updated (in MPICH2, use
dnl the top-level confdb files).  This separate directory is used for
dnl the moment to allow ROMIO to be separatedly distributed.
dnl scripts.
AC_CONFIG_AUX_DIR(confdb)

#
# Check that an arch was set
# If it wasn't set, try to guess using "util/tarch"
#
# Sometimes tarch looses its execute bit (!)
if test -s $srcdir/util/tarch -a ! -x $srcdir/util/tarch ; then
    chmod a+x $srcdir/util/tarch
fi
if test -z "$ARCH" -a -x $srcdir/util/tarch ; then
    AC_MSG_CHECKING(for architecture)
    ARCH=`$srcdir/util/tarch | sed s/-/_/g`
    if test -z "$ARCH" ; then
       AC_MSG_RESULT(Unknown!)
       AC_MSG_ERROR([Error: Couldn\'t guess target architecture, you must 
set an architecture type with the environment variable ARCH]) 
    fi 
    eval "arch_$ARCH=1"
    AC_MSG_RESULT($ARCH)
fi
#
# check for valid architecture.  Use __ so that _ALPHA_ does not match
# LINUX_ALPHA_
#### WE SHOULD REMOVE THIS SOON
grep __"$ARCH"_ $srcdir/.config_params > /dev/null 2>&1
if test $? != 0 ; then
   AC_MSG_WARN([Unknown architecture $arch... proceeding anyway])
fi
#
#
# Find the home directory if not specified
if test "X$srcdir" != "X." -a -s $srcdir/mpi-io/Makefile.in ; then 
    ROMIO_HOME_TRIAL=$srcdir
else
    # Take advantage of autoconf2 features
    if test -n "$ac_confdir" ; then
        ROMIO_HOME_TRIAL=$ac_confdir
    else
        if test -s configure ; then
	    ROMIO_HOME_TRIAL=`pwd`
	else
	    ac_confdir=`dirname "$0" 2>/dev/null`
	    if test -n "$ac_confdir" ; then
	        ROMIO_HOME_TRIAL=$ac_confdir
	    fi
	fi
    fi
fi
AC_MSG_RESULT([ROMIO home directory is $ROMIO_HOME_TRIAL])
ROMIO_HOME=$ROMIO_HOME_TRIAL

# get a fully qualified pathname for our build directory
top_build_dir=`pwd`
# used in romioinstall
AC_SUBST(top_build_dir)

#
# Create the "autoconf" style directory names...
# Most of these are done for us; add the documentation directories
#
# mandir is the root for the man pages
if test -z "$mandir" ; then mandir='${prefix}/man' ; fi
AC_SUBST(mandir)
if test -z "$docdir" ; then docdir='${prefix}/doc' ; fi
AC_SUBST(docdir)
if test -z "$htmldir" ; then htmldir='${prefix}/www' ; fi
AC_SUBST(htmldir) 
#
# check for valid file system
if test -n "$FILE_SYSTEM" ; then
   # if multiple filesystems are passed in, they are '+'-delimited
   # we could set the IFS to tokenize FILE_SYSTEM, but the FILE_SYSTEM env var
   # is used in multiple places in the build system: get rid of the '+'s so we
   # can use the 'for x in $FILE_SYSTEM ...' idiom 
   FILE_SYSTEM=`echo $FILE_SYSTEM|sed -e 's/\+/ /g'`
   for x in $FILE_SYSTEM
   do
      found=no
      # We could also do test -d "ad_$y" to test for known file systems
      # based on having access to the adio code.  Then adding a file 
      # system would not require changing configure to change known_filesystems
      for y in $known_filesystems ; do 
          if test $x = $y ; then
	      found=yes
	      eval "file_system_`echo $x`=1"
	      break
	  fi
      done
      if test "$found" = "no" ; then
         AC_MSG_WARN([Unknown file system $x... proceeding anyway])
      fi
   done
fi
#
# If we are building within a known MPI implementation, we must avoid the
# tests about an existing implementation
if test "$FROM_MPICH" != no -o "$FROM_MPICH2" != no -o "$FROM_LAM" != no ; then
    WITHIN_KNOWN_MPI_IMPL=yes
else
    WITHIN_KNOWN_MPI_IMPL=no
fi
# check for valid MPI implementation
if test -n "$MPI" ; then
   found=no
   for mpi in $known_mpi_impls ; do
      if test "${MPI}_mpi" = "$mpi" ; then
          found=yes
	  break
      fi
   done
   if test $found = no ; then
      AC_MSG_WARN([Unknown MPI implementation $MPI... proceeding anyway])
   fi
fi
#
# check for valid MPI include directory if specified
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   if test -n "$MPI_INCLUDE_DIR"; then
      if test ! -f "$MPI_INCLUDE_DIR/mpi.h" ; then
         AC_MSG_ERROR([Include file $MPI_INCLUDE_DIR/mpi.h not found])
      fi
   else
#     assume that mpi.h is in the default path
#     set MPI_INCLUDE_DIR to ".", so that it translates to -I. in the
#     compile command. Some compilers complain if it's only -I
      MPI_INCLUDE_DIR=.
   fi
else 
   MPI_INCLUDE_DIR=.
fi
#
# check for valid MPI library if specified
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   if test -n "$MPI_LIB" ; then
      if test ! -f "$MPI_LIB" ; then
         AC_MSG_ERROR([MPI library $MPI_LIB not found])
      fi
   fi
fi
#
#
AR="${AR:-ar} cr$AR_LOCAL"
if test -z "$RANLIB" ; then
    AC_PROG_RANLIB
fi
MAKE=${MAKE:-make}
#
# USER_CFLAGS and USER_FFLAGS are used only in test/Makefile.in
if test $DEBUG = "yes"; then
    USER_CFLAGS="$CFLAGS -g"
    USER_FFLAGS="$FFLAGS -g"
else
    USER_CFLAGS="$CFLAGS -O"
    USER_FFLAGS="$FFLAGS -O"
fi
#
# Here begin the architecture-specific tests.  
# --------------------------------------------------------------------------
# We must first select the C and Fortran compilers.  Because of the 
# way that the PROG_CC autoconf macro works (and all of the macros that
# require it, including CHECK_HEADERS), that macro must occur exactly
# once in the configure.in file, at least as of autoconf 2.57 .  
# Unfortunately, this requirement is not enforced.  To handle this,
# we first case on the architecture; then use PROG_CC, then case on the
# architecture again for any arch-specific features.  We also set the
# C_DEBUG_FLAG and F77_DEBUG_FLAG in case debugging is selected.
# 
# For the MPICH and MPICH2 configures, the compilers will already be
# selected, so most of the compiler-selection code will be bypassed.
# --------------------------------------------------------------------------
# For historical reasons
if test -z "$FC" ; then 
    FC=$F77
fi
#
C_DEBUG_FLAG="-g"
F77_DEBUG_FLAG="-g"
C_OPT_FLAG=${CFLAGS:-"-O"}
# MPICH1 uses OPTFLAGS and OPTFLAGSC to specify separate optimization
# flags for the C compiler (this is better that adding it to the
# undifferentiated CFLAGS, at least on input).
if test -n "$OPTFLAGS" ; then
    C_OPT_FLAG="$C_OPT_FLAG $OPTFLAGS"
fi
if test -n "$OPTFLAGSC" ; then
    C_OPT_FLAG="$C_OPT_FLAG $OPTFLAGSC"
fi
case $ARCH in 
     solaris|solaris86)
     CC=${CC:-cc}
     F77=${FC:-f77}
     if test "$CC" != "gcc" ; then
	C_DEBUG_FLAG="-g -v"
     fi
     ;;
     
     rs6000)
     F77=${FC}
     # Try to use mpcc if no CC specified
     AC_PROGRAMS_CHECK(CC, mpcc, cc)
     if test $NOF77 = 0 && test -z "$F77"; then 
        AC_PROGRAMS_CHECK(F77, mpxlf, f77)
     fi
     ;;

     tflop|tflops)
     CC=${CC:-pgcc}
     F77=${FC:-pgf77}
     CFLAGS="$CFLAGS -cougar -D__PUMA"
     if test "$CC" = "pgcc" ; then
         C_OPT_FLAG="-Knoieee -Mvect -O3"
     fi
     ;;
     
     freebsd|LINUX|netbsd|openbsd|LINUX_ALPHA)
     CC=${CC:-gcc}
     # Let the prog_f77 file g77/f77/others
     F77=${FC} 
     ;;

     SX4)
     CC=${CC:-mpicc}
     F77=${FC:-mpif90}
     if test $DEBUG != "yes" ; then
        USER_FFLAGS="$FFLAGS -Chopt"
        F77_OPT_FLAG="-Chopt"
    fi
    ;;

    hpux|sppux)
    C_DEBUG_FLAG="-g +w1"
    ;;

    alpha|ALPHA)
    CC=${CC:-cc}
    F77=${FC:-f77}
    dnl CFLAGS="$CFLAGS -g -std1 -warnprotos -verbose"
    C_DEBUG_FLAG="-g -verbose"
    ;;

    CRAY)
    CC=${CC:-cc}
    F77=${FC:-f90}
    NOF77=1
    CFLAGS="$CFLAGS -D_UNICOS"
    ;;

    sgi|IRIX64|IRIX32|IRIXN32)
    arch_IRIX=1
    CC=${CC:-cc}
    F77=${FC:-f77}
    C_DEBUG_FLAG="-g -fullwarn"
    ;;

    sgi5)
    ;;

    *)
    # Fall-through case.  Take FC 
    F77=${FC:-f77}
    ;;
esac

AC_PROG_CC
if test "$NOF77" != 1 ; then
    # Grrr.   The autoconf test for F77 will abort the configure
    # if no compiler is found.  We'd prefer to simply turn off
    # support for Fortran, and/or give a more informative message.
    AC_PROG_F77
fi
if test "$CC" = "gcc" -a -z "$C_DEBUG_FLAG" ; then
     C_DEBUG_FLAG="-g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
fi
if test $DEBUG = "yes" ; then
    CFLAGS="$CFLAGS $C_DEBUG_FLAG"
else 
    CFLAGS="$CFLAGS $C_OPT_FLAG"
fi

# ---------------------------------------------------------------------------
# Here go the rest of the tests
# ---------------------------------------------------------------------------
if test -n "$arch_solaris" || test -n "$arch_solaris86" ; then
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test $MPI = "mpich" ; then
        TEST_CC=mpicc
        TEST_F77=mpif77
    else
        TEST_CC="$CC"
        TEST_F77="$F77"
    fi
    AR="ar cr"
# solaris does not have l option to ar
fi


if test -n "$arch_rs6000"; then
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    AC_DEFINE(AIX,1,[Define for AIX])
# assume long long exists.
    longlongsize=${longlongsize:-8} 
    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
fi    
#

if test -n "$arch_tflop" || test -n "$arch_tflops"; then
    # TFLOP_FLAGS="-cougar -D__PUMA"
    AR="xar cr$AR_LOCAL"
    RANLIB="xranlib"
    MPI_LIB="$MPI_LIB"
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_ufs=1
        FILE_SYSTEM="ufs"
    fi
fi
#
if test -n "$arch_freebsd" || test -n "$arch_LINUX" || test -n "$arch_LINUX_ALPHA" || test -n "$arch_netbsd" || test -n "$arch_openbsd" ; then
    if test -n "$arch_freebsd" || test -n "$arch_netbsd" || test -n "$arch_openbsd"; then
        longlongsize=${longlongsize:-0}
	# printf doesn't work properly and no integer*8 as far as I can tell
    fi
    # Find the CPP before the header check
    AC_PROG_CPP
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
fi    
#
if test -n "$arch_SX4" ; then
    have_aio=no
    AC_DEFINE(SX4,1,[Define for NEC SX4])
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_sfs=1
        file_system_nfs=1
        FILE_SYSTEM="sfs nfs"
    fi
    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
fi
#
if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
    have_aio=no
    RANLIB=":"
    if test -z "$MPI"; then
        if test -f "/opt/mpi/include/mpi.h" ; then
            echo "assuming that you want to use ROMIO with HP MPI"
            MPI=hp
        else 
            echo "assuming that you want to use ROMIO with MPICH"
            MPI=mpich
        fi            
    fi
    if test $MPI = "mpich" ; then
        mpi_mpich=1
        MPI_LIB="$MPI_LIB -lV3"
        CC=${CC:-cc -Ae}
        F77=${FC:-f77 +U77}
    fi
    if test $MPI = "hp" ; then
        mpi_hp=1
        CC=${CC:-mpicc -Ae}
        F77=${FC:-mpif77 +U77}
    fi
    if test $MPI = "lam" && test "$FC" != ""; then
        F77="$F77 +U77"
    fi
    FTESTDEFINE="external iargc, getarg"
    if test -n "$arch_hpux" ; then
        CFLAGS="$CFLAGS -D_LARGEFILE64_SOURCE"
        AC_DEFINE(HPUX,1,[Define for HPUX])
        if test $MPI = "hp" ; then
           F77=${FC:-mpif90 +U77}
        else
           F77=${FC:-f90 +U77}
        fi
    else
        AC_DEFINE(SPPUX,1,[Define for SPPUX (Convex)])
    fi

    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
    if test "$CC" != "gcc" ; then
        ROMIO_TCFLAGS="-Ae"
    fi
    if test "$F77" != "g77" ; then
        ROMIO_TFFLAGS="+U77"
    fi
fi
#
if test -n "$arch_alpha" || test -n "$arch_ALPHA" ; then
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi

    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
    ROMIO_LIBLIST="$ROMIO_LIBLIST -laio"
fi    
#
if test -n "$arch_CRAY" ; then
    NOF77=1
    FTESTDEFINE="integer ilen"
    F77GETARG="call pxfgetarg(i, str, ilen, ierr)"
    have_aio=no
    RANLIB=":"
    AC_DEFINE(CRAY,1,[Define if Cray])
    if test -z "$MPI" || test -n "$mpi_sgi" ; then
        MPI=cray
        mpi_cray=1
        mpi_sgi=""
# above is to disable configure tests specific to SGI MPI
        AC_DEFINE(MPISGI,1,[Define if SGI MPI])
        AC_DEFINE(HAVE_MPI_COMBINERS,1,[Define if MPI supports datatype combiners])
        AC_DEFINE(NO_MPI_SGI_type_is_contig,1,[Define if no types show contig])
    fi
#       MPISGI needed because of error in Cray's and SGI's 
#       MPI_Type_get_contents (does not increment reference count).
#       Others needed because MPISGI needed.

    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
fi
#
if test -n "$arch_sgi" ; then
    arch_IRIX=1
    ARCH=IRIX
fi
if test -n "$arch_IRIX64" || test -n "$arch_IRIX32" || test -n "$arch_IRIXN32" ; then
    arch_IRIX=1
fi
if test -n "$arch_sgi5" ; then
    arch_IRIX5=1
    ARCH=IRIX
fi
#
PAC_GET_SPECIAL_SYSTEM_INFO
#
# special case 'sgi5' for use on MESHINE which is much like an SGI running
# irix 5 with r4400 chips, but does not have 'hinv', so above code doesn't
# work
if test -n "$arch_sgi5"; then
   osversion=5
   cputype=4400
   IRIXARCH="$ARCH_$osversion"
   IRIXARCH="$IRIXARCH_$cputype"
# now set arch_IRIX to 1
   arch_IRIX=1
   echo "IRIX-specific architecture is $IRIXARCH"
   AC_DEFINE(IRIX,1,[Define if IRIX])
fi
#
if test -n "$arch_IRIX"; then
   if test $osversion = 4 ; then
	RANLIB="ar ts"
        if test -n "$mpi_sgi"; then
            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 4.x])
        fi
   elif test $osversion = 5 ; then
        if test -n "$mpi_sgi"; then
            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 5.x])
        fi
   elif test $osversion = 6 ; then
	if test -z "$MPI"; then
	    if test "$FROM_MPICH2" = "yes" ; then
	        # Building with MPICH2.  Distinguish from MPICH-1
		MPI=mpich2
		mpi_mpich2=1
            elif test -f "/usr/include/mpi.h" ; then
                AC_MSG_WARN([assuming that you want to use ROMIO with SGI\'s MPI])
                MPI=sgi
                mpi_sgi=1
            else 
	        AC_MSG_WARN([assuming that you want to use ROMIO with MPICH])
                MPI=mpich
                mpi_mpich=1
            fi            
	fi
        RANLIB=":"
        AC_DEFINE(AIO_SIGNOTIFY_NONE,1,[Define if no signotify])
	if test $cputype -ge 5000 ; then
            MIPS=4
        else 
            MIPS=3
        fi
   fi
   if test -n "$mpi_sgi" && test -z "$MPI_LIB" ; then
       MPI_LIB="-lmpi"
   fi
#  check if pread64 is defined
   PAC_HAVE_PREAD64
#
   if test -z "$FILE_SYSTEM" ; then
       file_system_nfs=1
       FILE_SYSTEM="nfs"
       AC_MSG_CHECKING(for xfs)
       AC_TRY_COMPILE([
#include <aio.h>],
[aiocb64_t *t1;],file_system_xfs=1;FILE_SYSTEM="xfs $FILE_SYSTEM";)
       if test "$file_system_xfs" = 1 ; then 
          AC_MSG_RESULT(yes)
       else
          AC_MSG_RESULT(no)
          file_system_ufs=1
          FILE_SYSTEM="ufs $FILE_SYSTEM"
       fi
   fi
   AC_DEFINE(IRIX,1,[Define if IRIX])
   MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
   MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
fi

AC_HAVE_FUNCS(memalign)

#
# Question: Should ROMIO under MPICH2 ignore the Fortran tests, since 
# MPICH2 provides all of the Fortran interface routines?
#
if test $NOF77 = 0 ; then
    echo "checking Fortran external names"
    PAC_GET_FORTNAMES
    if test -n "$WDEF" ; then
        CFLAGS="$CFLAGS $WDEF"
    fi
    dnl PAC_PROG_F77_NAME_MANGLE
    dnl (need to set the new name format)
    rm -f test/mpif.h
    if test "$MPI_INCLUDE_DIR" != "." && test $WITHIN_KNOWN_MPI_IMPL = no ; then
        if test ! -d test ; then mkdir test ; fi
        ln -s $MPI_INCLUDE_DIR/mpif.h test
    fi
else 
    F77=":"
fi
#
AC_C_INLINE

# Header files
# Find the CPP before the header check
AC_PROG_CPP
AC_CHECK_HEADERS(unistd.h fcntl.h malloc.h stddef.h)
#
CROSS_SIZEOF_INT=${CROSS_SIZEOF_INT:-0}
CROSS_SIZEOF_VOID_P=${CROSS_SIZEOF_VOID_P:-0}
AC_CHECK_SIZEOF(int,$CROSS_SIZEOF_INT)
AC_CHECK_SIZEOF(void*,$CROSS_SIZEOF_VOID_P)
AC_CACHE_CHECK([for int large enough for pointers],
pac_cv_int_hold_pointer,[
if test "$ac_cv_sizeof_int" = "0" -o \
	"$ac_cv_sizeof_voidp" = "0" ; then
    pac_cv_int_hold_pointer=unknown
elif test "$ac_cv_sizeof_int" -lt "$ac_cv_sizeof_voidp" ; then
    pac_cv_int_hold_pointer=no
else
    pac_cv_int_hold_pointer=yes
fi
])
if test "$pac_cv_int_hold_pointer" != yes ; then
    AC_DEFINE(INT_LT_POINTER,1,[Define if int smaller than pointer])
fi
#
dnl The original ROMIO configure used a set of complex tests here; this
dnl is a partial reworking using the autoconf2 sizeof macros, and allowing
dnl for the standardized CROSS_xxx varaibles for cross-compilation environments
# LL is the printf-style format name for output of a MPI_Offset.
# We have to match this to the type that we use for MPI_Offset.
CROSS_SIZEOF_LONG_LONG=${CROSS_SIZEOF_LONG_LONG:-0}
AC_CHECK_SIZEOF(long long,$CROSS_SIZEOF_LONG_LONG)
if test "$ac_cv_sizeof_long_long" != 0 ; then
    if test "$ac_cv_sizeof_long_long" = "8" ; then
       AC_DEFINE(HAVE_LONG_LONG_64,1,[Define if long long is 64 bits])
       MPI_OFFSET_TYPE="long long"
       DEFINE_MPI_OFFSET="typedef long long MPI_Offset;"
       FORTRAN_MPI_OFFSET="integer*8"
       LL="lld"
    elif test "$ac_cv_sizeof_long_long" = "$ac_cv_sizeof_int" ; then
       MPI_OFFSET_TYPE="int"
       DEFINE_MPI_OFFSET="typedef int MPI_Offset;"
       FORTRAN_MPI_OFFSET="integer"
       AC_DEFINE(MPI_OFFSET_IS_INT,1,[Define if MPI_Offset is int])
       LL="d"
       MPI_OFFSET_KIND1="!"
       MPI_OFFSET_KIND2="!"
    else
       echo "defining MPI_Offset as long in C and integer in Fortran" 
       MPI_OFFSET_TYPE="long"
       DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
       FORTRAN_MPI_OFFSET="integer"
       LL="ld"
       MPI_OFFSET_KIND1="!"
       MPI_OFFSET_KIND2="!"
    fi
else
    echo "defining MPI_Offset as long in C and integer in Fortran" 
    MPI_OFFSET_TYPE="long"
    DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
    FORTRAN_MPI_OFFSET="integer"
    LL="ld"
    MPI_OFFSET_KIND1="!"
    MPI_OFFSET_KIND2="!"
fi


#
if test -n "$longlongsize"; then
   if test $WITHIN_KNOWN_MPI_IMPL = no ; then
       PAC_MPI_LONG_LONG_INT
   else
       AC_DEFINE(HAVE_MPI_LONG_LONG_INT,1,[Define if supports long long int])
   fi
fi
#
if test -n "$OFFSET_KIND" -a "A$MPI_OFFSET_KIND1" = "A!" ; then 
  MPI_OFFSET_KIND1="        INTEGER MPI_OFFSET_KIND"
  MPI_OFFSET_KIND2="        PARAMETER (MPI_OFFSET_KIND=$OFFSET_KIND)"
else
 if test "$FORTRAN_MPI_OFFSET" = "integer*8" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 && test $NOF90 = 0 ; then
   PAC_MPI_OFFSET_KIND
 fi
 #
  if test "$FORTRAN_MPI_OFFSET" = "integer" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 && test $NOF90 = 0 ; then
   PAC_MPI_OFFSET_KIND_4BYTE
  fi
fi
#
# check if MPI_Info functions are defined in the MPI implementation
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   PAC_MPI_INFO
else
   AC_DEFINE(HAVE_MPI_INFO,1,[Define if MPI Info is available])
   HAVE_MPI_INFO="#define HAVE_MPI_INFO"
   MPI_FINFO1="!"
   MPI_FINFO2="!"
   MPI_FINFO3="!"
   MPI_FINFO4="!"
fi   
#
if test -n "$mpi_sgi"; then
dnl   if test -z "$HAVE_MPI_INFO" ; then
dnl      PAC_CHECK_MPI_SGI_INFO_NULL  # is MPI_INFO_NULL defined in mpi.h?
dnl   fi
   PAC_TEST_MPI_SGI_type_is_contig
   PAC_TEST_MPI_COMBINERS
   PAC_TEST_MPI_HAVE_OFFSET_KIND
fi
#
# check if darray and subarray constructors are defined in the MPI 
# implementation 
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   PAC_MPI_DARRAY_SUBARRAY
fi
if test $FROM_MPICH2 = yes ; then
   dnl Made this a message instead of a warning because the warning is
   dnl likely to confuse users.
   AC_MSG_RESULT([Overriding Array test for MPICH2])
   unset BUILD_MPI_ARRAY
   AC_DEFINE(HAVE_MPI_DARRAY_SUBARRAY,1,[Define if Darray is available])
   HAVE_MPI_DARRAY_SUBARRAY="#define HAVE_MPI_DARRAY_SUBARRAY"
   MPI_FARRAY1="!"
   MPI_FARRAY2="!"
   MPI_FARRAY3="!"
   MPI_FARRAY4="!"
   MPI_FARRAY5="!"
   MPI_FARRAY6="!"
   MPI_FARRAY7="!"
fi   
#
#
# Test for weak symbol support...
# We can't put # in the message because it causes autoconf to generate
# incorrect code
HAVE_WEAK_SYMBOLS=0
if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
# multiple secondary definitions not allowed by HP compilers
# Fortran interface for HP already uses one secondary defn. 
# therefore, do not use this method for profiling interface.
# build profiling interface explicitly.
   TRY_WEAK_SYMBOLS=0
fi
if test $TRY_WEAK_SYMBOLS = 1 ; then
  AC_MSG_CHECKING([for weak symbol support])
  AC_TRY_LINK([
extern int PFoo(int);
#pragma weak PFoo = Foo
int Foo(int a) { return a; }
],[return PFoo(1);],has_pragma_weak=1)
  #
  # Some systems (Linux ia64 and ecc, for example), support weak symbols
  # only within a single object file!  This tests that case.
  # Note that there is an extern int PFoo declaration before the
  # pragma.  Some compilers require this in order to make the weak symbol
  # extenally visible.  
if test "$has_pragma_weak" = 1 ; then
    AC_MSG_RESULT([pragma weak])
    AC_MSG_CHECKING([that weak symbols are visible to other files])
    rm -f conftest*
    cat >>conftest1.c <<EOF
extern int PFoo(int);
#pragma weak PFoo = Foo
int Foo(int);
int Foo(int a) { return a; }
EOF
    cat >>conftest2.c <<EOF
extern int PFoo(int);
int main(int argc, char **argv) {
return PFoo(0);}
EOF
    ac_link2='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest1.c conftest2.c $LIBS >conftest.out 2>&1'
    if eval $ac_link2 ; then
        AC_MSG_RESULT(yes)
    else
      echo "$ac_link2" 1>&AC_FD_CC
      echo "Failed program was" 1>&AC_FD_CC
      cat conftest1.c 1>&AC_FD_CC
      cat conftest2.c 1>&AC_FD_CC
      if test -s conftest.out ; then cat conftest.out 1>&AC_FD_CC ; fi
      AC_MSG_RESULT(no)
      has_pragma_weak=0
    fi
    rm -f conftest*
  fi
  if test "$has_pragma_weak" = 1 ; then
    HAVE_WEAK_SYMBOLS=1
    AC_DEFINE(HAVE_PRAGMA_WEAK,1,[Define if pragma weak available])
  else
    AC_TRY_LINK([
extern int PFoo(int);
#pragma _HP_SECONDARY_DEF Foo PFoo
int Foo(int a) { return a; }
],[return PFoo(1);],has_pragma_hp_secondary=1)
    if test "$has_pragma_hp_secondary" = 1 ; then 
        AC_MSG_RESULT([pragma _HP_SECONDARY_DEF])
        HAVE_WEAK_SYMBOLS=1
        AC_DEFINE(HAVE_PRAGMA_HP_SEC_DEF,1,[Define for HP weak pragma])
    else
        AC_TRY_LINK([
extern int PFoo(int);
#pragma _CRI duplicate PFoo as Foo
int Foo(int a) { return a; }
],[return PFoo(1);],has_pragma_cri_duplicate=1)
        if test "$has_pragma_cri_duplicate" = 1 ; then
	    AC_MSG_RESULT([pragma _CRI duplicate x as y])
	    HAVE_WEAK_SYMBOLS=1
	    AC_DEFINE(HAVE_PRAGMA_CRI_DUP,1,[Define for CRAY weak dup])
        else    
            AC_MSG_RESULT(no)
        fi
    fi
  fi
fi
if test "$HAVE_WEAK_SYMBOLS" = 1 ; then
    AC_DEFINE(HAVE_WEAK_SYMBOLS,1,[Define if weak symbols available])
fi
AC_SUBST(HAVE_WEAK_SYMBOLS)



#
# Check whether the MPI Offset type is compatible with struct flock
AC_MSG_CHECKING([whether struct flock compatible with MPI_Offset])
AC_TRY_COMPILE([#include <fcntl.h>],
[struct flock l;
 $MPI_OFFSET_TYPE a=1;
 l.l_start = a; 
 l.l_len   = a;
],pac_cv_struct_flock_and_mpi_offset=yes,pac_cv_struct_flock_and_mpi_offset=no)
AC_MSG_RESULT($pac_cv_struct_flock_and_mpi_offset)
# FIXME: We should look for struct flock64 and the F_SETLK64/F_GETLK64
# ADIOI_Set_lock could use these instead.
if test "$pac_cv_struct_flock_and_mpi_offset" = no ; then
    AC_MSG_CHECKING([whether struct flock compatible with int])
    AC_TRY_COMPILE([#include <fcntl.h>],
[struct flock l;
 int a=1;
 l.l_start = a; 
 l.l_len   = a;
],pac_cv_struct_flock_and_int=yes,pac_cv_struct_flock_and_int=no)
    AC_MSG_RESULT($pac_cv_struct_flock_and_int)
    if test "$pac_cv_struct_flock_and_int" = yes ; then
        AC_DEFINE(NEEDS_INT_CAST_WITH_FLOCK,1,[Define if l_start and l_len data should be cast as int])
    fi
    # FIXME.  Solaris header files define off_t as a UNION if 64bit file
    # sizes are selected.  Gah!
fi

#
# if FILE_SYSTEM is not set above, use ufs and nfs as default
#
if test -z "$FILE_SYSTEM" ; then
    file_system_ufs=1
    file_system_nfs=1
    FILE_SYSTEM="ufs nfs"
fi

# no matter what, always build testfs
file_system_testfs=1
FILE_SYSTEM="testfs $FILE_SYSTEM"

#
# Print list of configured file systems
#
# TODO: REMOVE BAD ONES FROM THE LIST SOMEHOW?
#
AC_MSG_CHECKING([configured file systems])
AC_MSG_RESULT([$FILE_SYSTEM])

if test -n "$file_system_nfs" ; then
    AC_DEFINE(ROMIO_NFS,1,[Define for ROMIO with NFS])
    AC_MSG_WARN([File locks may not work with NFS.  See the Installation and
users manual for instructions on testing and if necessary fixing this])
fi

if test -n "$file_system_panfs"; then
    AC_DEFINE(ROMIO_PANFS,1,[Define for ROMIO with PANFS])
fi
if test -n "$file_system_ufs"; then
    AC_DEFINE(ROMIO_UFS,1,[Define for ROMIO with UFS])
fi
if test -n "$file_system_hfs"; then
    AC_DEFINE(ROMIO_HFS,1,[Define for ROMIO with HFS])
fi
if test -n "$file_system_sfs"; then
    AC_DEFINE(ROMIO_SFS,1,[Define for ROMIO with SFS])
fi

if test -n "$file_system_pfs"; then
    AC_DEFINE(ROMIO_PFS,1,[Define for ROMIO with PFS])
fi

if test -n "$file_system_testfs"; then
    AC_DEFINE(ROMIO_TESTFS,1,[Define for ROMIO with TESTFS])
fi

if test -n "$file_system_xfs"; then
    AC_DEFINE(ROMIO_XFS,1,[Define for ROMIO with XFS])
    # Check for memalign value
    AC_CACHE_CHECK([for memory alignment needed for direct I/O],
    pac_cv_memalignval,
    [
    /bin/rm -f confmemalignval
    /bin/rm -f /tmp/romio_tmp.bin
    AC_TRY_RUN([
	#include <stdio.h>
	#include <unistd.h>
	#include <fcntl.h>
	#include <stdio.h>
	main() { 
	struct dioattr st;
	int fd = open("/tmp/romio_tmp.bin", O_RDWR | O_CREAT, 0644);
	FILE *f=fopen("confmemalignval","w");
	if (fd == -1) exit(1);
	if (!f) exit(1);
	fcntl(fd, F_DIOINFO, &st);
	fprintf( f, "%u\n", st.d_mem);
	exit(0);
	}
	],
	pac_cv_memalignval=`cat confmemalignval`,
	pac_cv_memalignval="unknown",pac_cv_memalignval="unknown"
    )
    /bin/rm -f confmemalignval
    /bin/rm -f /tmp/romio_tmp.bin
    ])
    if test -n "$pac_cv_memalignval" -a "$pac_cv_memalignval" != 0 -a \
	"$pac_cv_memalignval" != "unknown" ; then
        CFLAGS="$CFLAGS -DXFS_MEMALIGN=$pac_cv_memalignval"
    else
        AC_MSG_RESULT(assuming 128 for memory alignment)
        CFLAGS="$CFLAGS -DXFS_MEMALIGN=128"
    fi
fi

#
# Verify presence of pvfs.h, issue with int64
#
if test -n "$file_system_pvfs"; then
    CPPFLAGS="$CPPFLAGS $CFLAGS"
    AC_CHECK_HEADERS(pvfs.h,
    	AC_DEFINE(ROMIO_PVFS2,1,[Define for ROMIO with PVFS]),
	AC_MSG_ERROR([PVFS support requested but cannot find pvfs.h header file])
	)
    # Check for missing int64_t (intel version 8 compiler and -no-gcc
    # selected)
    AC_MSG_CHECKING([that pvfs.h can be compiled])
    AC_TRY_COMPILE([
        #include <pvfs.h>
        ],[
        ],pvfs_header_ok=yes,pvfs_header_ok=no
    )
    AC_MSG_RESULT($pvfs_header_ok)
    if test "$pvfs_header_ok" = no -a "$ac_cv_sizeof_long_long" = 8 ; then
        AC_MSG_CHECKING([if pvfs.h can be compiled if we define int64_t])
        # Try again, but with int64_t
        AC_TRY_COMPILE([
            typedef long long int int64_t;
            #include <pvfs.h>
            ],[
            ],
            pvfs_header_ok="yes with int64 definition"
        )
        AC_MSG_RESULT($pvfs_header_ok)
    fi
    if test "$pvfs_header_ok" = "yes with int64 definition" ; then
        AC_DEFINE(ROMIO_PVFS_NEEDS_INT64_DEFINITION,1,[Define if int64_t must be defined for PVFS])
    fi
    if test "$pvfs_header_ok" != "no" ; then
        AC_DEFINE(ROMIO_PVFS,1,[Define for ROMIO with PVFS])
	AC_DEFINE(HAVE_PVFS_SUPER_MAGIC, 1, [Define if PVFS_SUPER_MAGIC defined.])
    else
	AC_MSG_WARN(missing or broken pvfs.h header file; disabling ROMIO PVFS support)
    fi
fi

#
# Verify presence of pvfs2.h
#
if test -n "$file_system_pvfs2"; then
    CPPFLAGS="$CPPFLAGS $CFLAGS"
    AC_CHECK_HEADERS(pvfs2.h,
	AC_DEFINE(ROMIO_PVFS2,1,[Define for ROMIO with PVFS2])
	AC_DEFINE(HAVE_PVFS2_SUPER_MAGIC, 1, [Define if PVFS2_SUPER_MAGIC defined.]),
        AC_MSG_ERROR([PVFS2 support requested but cannot find pvfs2.h header file])                                        
    )
fi

if test -n "$file_system_gridftp"; then
	AC_DEFINE(ROMIO_GRIDFTP, 1, [Define for ROMIO with gridftp])
fi

#
# Check for presence and characteristics of async. I/O calls if
# not disabled.
#
# Q: Do we need to list some "other libs" to get things to link?
#
save_libs=$LIBS
LIBS=
#
# Some systems need pthreads to get AIO to work
#
if test "x$disable_aio" = "xno" ; then
    AC_SEARCH_LIBS(pthread_create,pthread,
        ROMIO_LIBLIST="$ROMIO_LIBLIST $LIBS"
        MPI_LIB="$MPI_LIB $LIBS"
        )
    LIBS=
    AC_SEARCH_LIBS(aio_write,aio rt,
        ROMIO_LIBLIST="$ROMIO_LIBLIST $LIBS"
        MPI_LIB="$MPI_LIB $LIBS"
        aio_write_found=yes
    )
fi
LIBS=$save_libs

if test "x$disable_aio" = "xno" -a -n "$aio_write_found" ; then
    AC_CHECK_HEADERS(signal.h)
    # Just because aio.h is found by CPP doesn't mean that we can use it
    # We try to compile it, not just read it.
    AC_MSG_CHECKING([if aio.h exists and can be compiled])
    AC_TRY_COMPILE([
#include <aio.h>],
[],have_aio_h=yes,have_aio_h=no)
    AC_MSG_RESULT($have_aio_h)
    if test "$have_aio_h" = yes ; then
        AC_DEFINE(HAVE_AIO_H,1,[Define if aio.h exists and can be compiled])
    fi

    AC_MSG_CHECKING([if sys/aio.h exists and can be compiled])
    AC_TRY_COMPILE([
#include <sys/aio.h>],
[],have_sys_aio_h=yes,have_sys_aio_h=no)
    AC_MSG_RESULT($have_sys_aio_h)
    if test "$have_sys_aio_h" = yes ; then
        AC_DEFINE(HAVE_SYS_AIO_H,1,[Define if sys/aio.h exists and can be compiled])
    fi
fi

if test "$have_aio_h" = "yes" -o "$have_sys_aio_h" = "yes" ; then

    # Check that aio is available (many systems appear to have aio
    # either installed improperly or turned off).
    # The test is the following: if not cross compiling, try to run a 
    # program that includes a *reference* to aio_write but does not call it
    # If the libraries are not set up correctly, then this will fail.
    save_libs=$LIBS
    LIBS="$LIBS $ROMIO_LIBLIST"
    AC_MSG_CHECKING([whether aio routines can be used])
    # Include aio.h and the aiocb struct (since we'll need these to 
    # actually use the aio_write interface).  Note that this will 
    # fail for some pre-POSIX implementations of the aio interface 
    # (an old IBM interface needs an fd argument as well)
    AC_TRY_RUN([
#include <sys/types.h>
#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif
#ifdef HAVE_AIO_H
#include <aio.h>
#endif
#ifdef HAVE_SYS_AIO_H
#include <sys/aio.h>
#endif
	int main(int argc, char **argv)
	{
            struct aiocb *aiocbp;
	    if (argc > 10) aio_write(aiocbp);
	    return 0;
	}
	],
	aio_runs=yes
	AC_MSG_RESULT(yes),
	aio_runs=no
	AC_MSG_RESULT(no),
	aio_runs=unknown
	AC_MSG_RESULT(unknown)
    )
    if test "$aio_runs" != "no" ; then
	AC_DEFINE(ROMIO_HAVE_WORKING_AIO, 1, Define if AIO calls seem to work)
    fi
    
    # now about that old IBM interface...
    # modern AIO interfaces have the file descriptor in the aiocb structure,
    # and will set ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_FILDES.  Old IBM
    # implementations pass the file descriptor as an argument to aio_write and
    # aio_read.  AIO still works on these platforms, but we have to test with
    # two-argument aio_write to avoid a false negative.  no need to worry about
    # the two-argument vs. one-argument aio_write and aio_read: ROMIO already
    # uses ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_FILDES to call aio_write and
    # aio_read correctly

    AC_MSG_CHECKING([for obsolete two-argument aio_write])
    AC_TRY_RUN([
#include <sys/types.h>
#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif
#ifdef HAVE_AIO_H
#include <aio.h>
#endif
#ifdef HAVE_SYS_AIO_H
#include <sys/aio.h>
#endif
	int main(int argc, char **argv)
	{
		int fd;
		struct aiocb *aiocbp;
		if (argc > 10) aio_write(fd, aiocbp);
		return 0;
	}
	],
	aio_two_arg_write=yes
	AC_MSG_RESULT(yes),
	aio_two_arg_write=no 
	AC_MSG_RESULT(no),
	aio_two_arg_write=unknown
	AC_MSG_RESULT(unknown)
    )

    if test "$aio_two_arg_write" != "no" -a "$aio_runs" != "yes" ; then
    	AC_DEFINE(ROMIO_HAVE_WORKING_AIO, 1, Define if AIO calls seem to work)
	AC_DEFINE(ROMIO_HAVE_AIO_CALLS_NEED_FILEDES, 1, Define if AIO calls need file descriptor)
    fi

    AC_MSG_CHECKING([for obsolete two-argument aio_suspend])
    AC_TRY_RUN([
#include <sys/types.h>
#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif
#ifdef HAVE_AIO_H
#include <aio.h>
#endif
#ifdef HAVE_SYS_AIO_H
#include <sys/aio.h>
#endif
	int main(int argc, char **argv)
	{
		struct aiocb *aiocbp;
		if (argc > 10) aio_suspend(1, &aiocbp);
		return 0;
	}
	],
	aio_two_arg_suspend=yes
	AC_MSG_RESULT(yes),
	aio_two_arg_suspend=no 
	AC_MSG_RESULT(no),
	aio_two_arg_suspend=unknown
	AC_MSG_RESULT(unknown)
    )

    if test "$aio_two_arg_suspend" != "no" -a "$aio_runs" != "yes" ; then
	AC_DEFINE(ROMIO_HAVE_AIO_SUSPEND_TWO_ARGS, 1, Define if aio_suspend needs two arguments)
    fi

    LIBS=$save_libs

    AC_MSG_CHECKING([for aio_fildes member of aiocb structure])
    AC_TRY_COMPILE([
	#ifdef HAVE_SIGNAL_H
	#include <signal.h>
	#endif
	#ifdef HAVE_AIO_H
	#include <aio.h>
	#endif
	#ifdef HAVE_SYS_AIO_H
	#include <sys/aio.h>
	#endif
	],[
	struct aiocb a;
	a.aio_fildes = 0;
	],
	AC_MSG_RESULT(yes)
	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_FILDES, 1, [Define if aiocb has aio_fildes member]),
	AC_MSG_RESULT(no)
    )
    AC_MSG_CHECKING(for aio_whence member of aiocb structure)
    AC_TRY_COMPILE([
	#ifdef HAVE_SIGNAL_H
	#include <signal.h>
	#endif
	#ifdef HAVE_AIO_H
	#include <aio.h>
	#endif
	#ifdef HAVE_SYS_AIO_H
	#include <sys/aio.h>
	#endif
	#include <sys/types.h>
	#include <unistd.h>
	],[
	struct aiocb a;
	a.aio_whence = SEEK_SET;
	],
	AC_MSG_RESULT(yes)
	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_WHENCE, 1, [Define if aiocb has aio_whence member]),
	AC_MSG_RESULT(no)
    )
    AC_MSG_CHECKING(for aio_handle member of aiocb structure)
    AC_TRY_COMPILE([
	#ifdef HAVE_SIGNAL_H
	#include <signal.h>
	#endif
	#ifdef HAVE_AIO_H
	#include <aio.h>
	#endif
	#ifdef HAVE_SYS_AIO_H
	#include <sys/aio.h>
	#endif
	],[
	struct aiocb a;
	aio_handle_t h;

	a.aio_handle = h;
	],
	AC_MSG_RESULT(yes)
	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_HANDLE, 1, [Define if aiocb has aio_handle member]),
	AC_MSG_RESULT(no)
    )
    AC_MSG_CHECKING(for aio_reqprio member of aiocb structure)
    AC_TRY_COMPILE([
	#ifdef HAVE_SIGNAL_H
	#include <signal.h>
	#endif
	#ifdef HAVE_AIO_H
	#include <aio.h>
	#endif
	#ifdef HAVE_SYS_AIO_H
	#include <sys/aio.h>
	#endif
	],[
	struct aiocb a;

	a.aio_reqprio = 0;
	],
	AC_MSG_RESULT(yes)
	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_REQPRIO, 1, [Define if aiocb has aio_reqprio member]),
	AC_MSG_RESULT(no)
    )	
    AC_MSG_CHECKING(for aio_sigevent member of aiocb structure)
    AC_TRY_COMPILE([
	#ifdef HAVE_SIGNAL_H
	#include <signal.h>
	#endif
	#ifdef HAVE_AIO_H
	#include <aio.h>
	#endif
	#ifdef HAVE_SYS_AIO_H
	#include <sys/aio.h>
	#endif
	],[
	struct aiocb a;

	a.aio_sigevent.sigev_signo = 0;
	],
	AC_MSG_RESULT(yes)
	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_SIGEVENT, 1, [Define if aiocb has aio_sigevent member]),
	AC_MSG_RESULT(no)
    )
	
fi
# End of aio-related tests

#
# Check for statfs (many) and specifically f_fstypename field (BSD)
#
AC_CHECK_HEADERS(sys/vfs.h sys/param.h sys/mount.h sys/statvfs.h)
AC_MSG_CHECKING([whether struct statfs properly defined])
AC_TRY_COMPILE([
    #ifdef HAVE_SYS_VFS_H
    #include <sys/vfs.h>
    #endif
    #ifdef HAVE_SYS_STATVFS_H
    #include <sys/statvfs.h>
    #endif
    #ifdef HAVE_SYS_PARAM_H
    #include <sys/param.h>
    #endif
    #ifdef HAVE_SYS_MOUNT_H
    #include <sys/mount.h>
    #endif
    ],[
    struct statfs f;
    ],
    pac_cv_have_statfs=yes,pac_cv_have_statfs=no
)
AC_MSG_RESULT($pac_cv_have_statfs)
# At this point, we could check for whether defining 
# __SWORD_TYPE as sizet_t or int/long (size of pointer)
# would help.  FIXME

if test "$pac_cv_have_statfs" = yes ; then
    AC_DEFINE(HAVE_STRUCT_STATFS,1,[Define if struct statfs can be compiled])
fi
	  
AC_MSG_CHECKING([for f_fstypename member of statfs structure])
AC_TRY_COMPILE([
    #include <sys/param.h>
    #include <sys/mount.h>
    #include <string.h>
    ],[
    struct statfs f;
    memset(&f, 0, sizeof(f));
    strncmp("nfs", f.f_fstypename, 3);
    ],
    pac_cv_have_statfs_f_fstypename=yes,
    pac_cv_have_statfs_f_fstypename=no
)
AC_MSG_RESULT($pac_cv_have_statfs_f_fstypename)
if test $pac_cv_have_statfs_f_fstypename = yes ; then
    AC_DEFINE(ROMIO_HAVE_STRUCT_STATFS_WITH_F_FSTYPENAME, 1,[Define if statfs has f_fstypename])
fi

#
# Check for stat and st_fstype field (NEC SX4)
#
AC_CHECK_HEADERS(sys/stat.h sys/types.h unistd.h)
AC_CHECK_FUNCS(stat,
    AC_DEFINE(HAVE_STAT, 1, Define if stat function is present)
    AC_MSG_CHECKING([for st_fstype member of stat structure])
    AC_TRY_COMPILE([
	#ifdef HAVE_SYS_TYPES_H
	#include <sys/types.h>
	#endif
	#ifdef HAVE_SYS_STAT_H
	#include <sys/stat.h>
	#endif
	#ifdef HAVE_UNISTD_H
	#include <unistd.h>
	#endif
	],[
	struct stat s;

	s.st_fstype = NULL;
	],
	AC_MSG_RESULT(yes)
	AC_DEFINE(ROMIO_HAVE_STRUCT_STAT_WITH_ST_FSTYPE, 1, Define if struct stat has a st_fstype member),
	AC_MSG_RESULT(no)
    )
)

#
# Check for statvfs and f_basetype field (Solaris, Irix, AIX, etc.)
#
AC_CHECK_HEADERS(sys/types.h sys/statvfs.h sys/vfs.h)
AC_CHECK_FUNCS(statvfs,
    AC_DEFINE(HAVE_STATVFS, 1, Define if statvfs function is present)
    AC_MSG_CHECKING([for f_basetype member of statvfs structure])
    AC_TRY_COMPILE([
	#ifdef HAVE_SYS_TYPES_H
	#include <sys/types.h>
	#endif
        #ifdef HAVE_SYS_VFS_H
        #include <sys/vfs.h>
        #endif
	#ifdef HAVE_SYS_STATVFS_H
	#include <sys/statvfs.h>
	#endif
	], [
	struct statvfs foo;

	foo.f_basetype = NULL;
	],
	AC_MSG_RESULT(yes)
	AC_DEFINE(ROMIO_HAVE_STRUCT_STATVFS_WITH_F_BASETYPE, 1, defined if struct statvfs has a f_basetype member),
	AC_MSG_RESULT(no)
    )
)

#
# Check for large file support.  Make sure that we can use the off64_t 
# type (in some cases, it is an array, and the ROMIO code isn't prepared for
# that).
#
AC_CHECK_HEADERS(unistd.h)
if test "$ac_cv_header_unistd_h" = "yes" ; then
    AC_CACHE_CHECK([for large file defines],ac_cv_has_large_file_defines,[
    AC_TRY_COMPILE([
#include <unistd.h>
        ], [
        #ifndef _LFS64_LARGEFILE
        #error no largefile defines
        #endif
        ],ac_cv_has_large_file_defines=yes,ac_cv_has_large_file_defines=no)])
    if test "$ac_cv_has_large_file_defines" = "yes" ; then
        # See if we can use them
    AC_CACHE_CHECK([whether off64_t is an scalar type],ac_cv_off64_t_scalar,[
    AC_TRY_COMPILE([
#define _LARGEFILE64_SOURCE
#define _FILE_OFFSET_BITS 64
#include <sys/types.h>
#include <unistd.h>
],[off64_t a = 3;],ac_cv_off64_t_scalar=yes,ac_cv_off64_t_scalar=no)])

        if test "$ac_cv_off64_t_scalar" = "yes" ; then
            CFLAGS="${CFLAGS} -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64"
        fi
    fi
fi


####################################################################
# We're about to mess with CC etc.  No more feature tests past here,
# because we may set CC to something that does not yet exist!
####################################################################

if test -n "$mpi_mpich"; then
   if test -z "$arch_SX4" ; then
      MPIOF_H_INCLUDED=1
   fi
   if test "$FROM_MPICH2" = no; then
      AC_DEFINE(NEEDS_MPI_TEST,1,[Define if mpi_test needed])
      AC_DEFINE(MPICH,1,[Define if using MPICH])
   fi
fi

if test -n "$mpi_sgi"; then
   AC_DEFINE(MPISGI,1,[Define if SGI MPI])
fi

if test -n "$mpi_lam"; then
   AC_DEFINE(MPILAM,1,[Define if using LAM/MPI])
fi

if test -n "$mpi_hp"; then
   AC_DEFINE(MPIHP,1,[Define if using HP MPI])
   if test "$NOF77" = 0; then
      PAC_CHECK_MPIOF_H
   fi
fi
#
AC_CHECK_FUNCS(strerror)
if test -z "$srcdir" -o "$srcdir" = "." ; then srcdir="$ROMIO_HOME" ; fi
AC_SUBST(srcdir)
# The master_top_srcdir is the location of the source for the building
# package.  This is used only as part of the MPICH2 build, including 
# the documentation targets mandoc, htmldoc, and latexdoc
if test -z "$master_top_srcdir" ; then
    if test "$FROM_MPICH2" = yes ; then
        AC_MSG_WARN([Could not determine master_top_srcdir])
    fi
fi
AC_SUBST(master_top_srcdir)
#
# Get the master builddir (which may be imported from above)
if test -z "$master_top_builddir" ; then
    master_top_builddir=`pwd`
fi
export master_top_builddir
AC_SUBST(master_top_builddir)
# Make sure the alternate spelling is used until we clean up all of the code
master_topbuild_dir=$master_top_builddir
export master_topbuild_dir
AC_SUBST(master_topbuild_dir)

# The following definitions are needed within adio/common/status_setb.c
if test "$FROM_MPICH" = yes ; then
   AC_DEFINE(MPICH,1,[Define if compiling within MPICH])
elif test "$FROM_MPICH2" = yes ; then 
   AC_DEFINE(ROMIO_INSIDE_MPICH2,1,[Define if compiling within MPICH2])
elif test "$FROM_MPILAM" = yes ; then
   AC_DEFINE(MPILAM,1,[Define if compiling within LAM/MPI])
fi

if test "$FROM_MPICH2" = no -a "$FROM_MPICH" = no ; then 
    if test -z "$LIBNAME"; then
        LIBNAME="$top_build_dir/lib/libmpio.a"
    fi
    #
    if test ! -d $top_build_dir/lib ; then 
        mkdir $top_build_dir/lib
    fi
else
    MPILIBNAME=${MPILIBNAME:-mpich}
    if test -z "$LIBNAME" ; then
        if test -d "$master_top_builddir/lib" ; then
            LIBNAME=$master_top_builddir/lib/lib${MPILIBNAME}.a
        else
            LIBNAME="$ROMIO_HOME/lib${MPILIBNAME}.a"
	fi
    fi
fi
if test "$FROM_MPICH2" != no ; then
    # use the error handlers from MPICH2
    MPIO_EXTRA_OBJECTS=
    MPIO_EXTRA_TMP_POBJECTS=
    MPIO_EXTRA_REAL_POBJECTS=
    # Use generalized request to get the multiple-completion routines
    MPIO_REQOBJECTS=
    MPIO_REQ_TMP_POBJECTS=
    MPIO_REQ_REAL_POBJECTS=
fi
AC_SUBST(MPIO_EXTRA_OBJECTS)
AC_SUBST(MPIO_EXTRA_TMP_POBJECTS)
AC_SUBST(MPIO_EXTRA_REAL_POBJECTS)
AC_SUBST(MPIO_REQOBJECTS)
AC_SUBST(MPIO_REQ_TMP_POBJECTS)
AC_SUBST(MPIO_REQ_REAL_POBJECTS)
#
# Use DOCTEXT instead of doctext
AC_CHECK_PROGS(DOCTEXT,doctext,true)
AC_SUBST(DOCTEXT)
#
if test $NOF77 = 1 ; then
   F77=":"
else
   FORTRAN_TEST="fperf fcoll_test fmisc pfcoll_test" 
fi
#
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   PAC_TEST_MPI
   PAC_NEEDS_FINT
else
   NEEDS_MPI_FINT=""
fi
#
if test "$MPI_INCLUDE_DIR" = "." ; then
   ROMIO_INCLUDE="-I../include"
else 
   ROMIO_INCLUDE="-I../include -I$MPI_INCLUDE_DIR"
fi
#
TEST_LIBNAME=$LIBNAME
MPIRUN=mpirun
#
# if MPICH, use mpicc in test programs
#
if test "$FROM_MPICH" = yes ; then
   MPICH_HOME=`dirname $ROMIO_HOME`
   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
   TEST_CC=$MPI_BIN_DIR/mpicc
   MPI_LIB=""
   ROMIO_INCLUDE=""
   USER_CFLAGS=""
   USER_FFLAGS=""
   TEST_LIBNAME=""
   MPIRUN=$MPI_BIN_DIR/mpirun
   if test -n "$arch_SX4" || test -n "$arch_hpux" ; then
      TEST_F77=$MPI_BIN_DIR/mpif90
   else
      TEST_F77=$MPI_BIN_DIR/mpif77
   fi
   CC=$MPI_BIN_DIR/mpicc
   # A later test will insert the mpi2-other/info and array directories based
   # on the value of BUILD_MPI_xxxx.  This lets MPICH2 turn these off,
   # since MPICH2 provides these routines elsewhere
   EXTRA_DIRS="mpi-io/fortran"
   # Some older implementations of the ADI do not include the 
   # MPID_Status_set_bytes routine.   This uses either the 
   # environment variable ADI3_WITHOUT_SET_BYTES or the
   # with arg --without-setbytes
   if test "$ADI2_WITHOUT_SET_BYTES" != yes -a \
           "$with_setbytes" != no ; then
       AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if have MPIR_Status_set_bytes])
   fi
elif test $FROM_LAM = yes ; then
   # LAM does have the status set bytes functionality
   AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if have MPIR_Status_set_bytes])
        
   # Used in the tests/ subdirectory for after ROMIO is built
   TEST_CC=mpicc
   TEST_F77=mpif77
   MPIRUN=mpirun 
   MPI_LIB=
   ROMIO_INCLUDE=
   USER_CFLAGS=
   USER_FFLAGS=
   TEST_LIBNAME=
   EXTRA_DIRS="mpi-io/fortran mpi2-other/info mpi2-other/info/fortran mpi2-other/array mpi2-other/array/fortran"
elif test $FROM_MPICH2 = yes ; then
   # For now, separate the mpich2 from mpich cases
   MPICH_HOME=`dirname $ROMIO_HOME`
   MPICH_HOME=`dirname $MPICH_HOME`
   MPICH_HOME=`dirname $MPICH_HOME`
   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
   # No special compiler script.
   # BUT we need the include paths
   # CC="$CC -I${use_top_srcdir}/src/include -I${top_build_dir}/src/include"
   # TEST_CC="$CC"
   # MPI_LIB="$LIBNAME"
   # To allow ROMIO to work with the LIBTOOL scripts, we want to 
   # work directly with the CC, not the mpicc, compiler.
   # Note that in the "FROM_MPICH2" case, the CPPFLAGS and INCLUDES are already
   # properly set
   #CC=${top_build_dir}/bin/mpicc
   #
   # set the compilers to the ones in MPICH2 bin directory (master_top_builddir/bin)
   TEST_CC=${master_top_builddir}/bin/mpicc
   TEST_F77=${master_top_builddir}/bin/mpif77
   ROMIO_INCLUDE=""
   USER_CFLAGS=""
   USER_FFLAGS=""
   TEST_LIBNAME=""
   MPIRUN=${master_top_builddir}/bin/mpiexec
   #
   # Turn off the building of the Fortran interface and the Info routines
   EXTRA_DIRS=""
   AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if status_set_bytes available])
   DEFINE_HAVE_MPI_GREQUEST="#define HAVE_MPI_GREQUEST"
fi
#
#
# feature tests:  we can't test features if building as part of MPICH because
# we don't yet have an implementation against which we can test
#
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   PAC_TEST_MPIR_STATUS_SET_BYTES
   PAC_TEST_MPI_GREQUEST
   AC_DEFINE(PRINT_ERR_MSG,1,[Define for printing error messages])
fi
#
if test -z "$TEST_CC" ; then
   TEST_CC="$CC"
fi
if test -z "$TEST_F77" ; then
   TEST_F77="$F77"
fi
#
AC_CHECK_FUNCS(strdup)
if test "$ac_cv_func_strdup" = "yes" ; then
    # Do we need to declare strdup?
    PAC_FUNC_NEEDS_DECL([#include <string.h>],strdup)
fi
AC_CHECK_FUNCS(snprintf)
if test "$ac_cv_func_snprintf" = "yes" ; then
    # Do we need to declare snprintf?
    PAC_FUNC_NEEDS_DECL([#include <stdio.h>],snprintf)
fi
AC_CHECK_FUNCS(lstat)
if test "$ac_cv_func_lstat" = "yes" ; then
    # Do we need to declare lstat?
    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],lstat)
fi
AC_CHECK_FUNCS(readlink)
if test "$ac_cv_func_readlink" = "yes" ; then
    # Do we need to declare readlink?
    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],readlink)
fi
AC_CHECK_FUNCS(fsync)
if test "$ac_cv_func_fsync" = "yes" ; then
    # Do we need to declare fsync?
    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],fsync)
fi
AC_CHECK_FUNCS(ftruncate)
if test "$ac_cv_func_ftruncate" = "yes" ; then
    # Do we need to declare ftruncate?
    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],ftruncate)
fi
#
# Create the directory lists for the Makefile
FILE_SYS_DIRS=""
for dir in $FILE_SYSTEM ; do
    FILE_SYS_DIRS="$FILE_SYS_DIRS adio/ad_$dir"
done
EXTRA_SRC_DIRS=""
GLUE_DIR=""
if test "$FROM_MPICH2" = yes -o "${MPI}_mpi" = "mpich2_mpi"; then
    GLUE_DIR="mpi-io/glue/mpich2"
elif test "$FROM_MPICH" = yes -o "${MPI}_mpi" = "mpich_mpi"; then
    GLUE_DIR="mpi-io/glue/mpich1"
else
    GLUE_DIR="mpi-io/glue/default"
fi
if test "$BUILD_MPI_INFO" = 1 ; then
    EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/info"
    if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
        EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/info/fortran"
    fi
fi
if test "$BUILD_MPI_ARRAY" = 1 ; then
    EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/array"
    if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
        EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/array/fortran"
    fi
fi
if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
   EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi-io/fortran"
fi
AC_SUBST(EXTRA_SRC_DIRS)
AC_SUBST(FILE_SYS_DIRS)
AC_SUBST(GLUE_DIR)

#
CFLAGS="$CFLAGS -DHAVE_ROMIOCONF_H"
#

if test -n "$MPIOF_H_INCLUDED"; then
   F77MPIOINC=""
else 
   F77MPIOINC="include 'mpiof.h'"
fi

PAC_C_RESTRICT
PAC_C_GNU_ATTRIBUTE

echo "setting CC to $CC"
echo "setting F77 to $F77"
echo "setting TEST_CC to $TEST_CC"
echo "setting TEST_F77 to $TEST_F77"
echo "setting CFLAGS to $CFLAGS"
echo "setting USER_CFLAGS to $USER_CFLAGS"
echo "setting USER_FFLAGS to $USER_FFLAGS"
#
VPATH='VPATH = .:${srcdir}'
AC_SUBST(VPATH)
AC_SUBST(ARCH)
AC_SUBST(FILE_SYSTEM)
AC_SUBST(CC)
AC_SUBST(CPPFLAGS)
AC_SUBST(CFLAGS)
AC_SUBST(USER_CFLAGS)
AC_SUBST(USER_FFLAGS)
AC_SUBST(MIPS)
AC_SUBST(BITS)
AC_SUBST(MPI)
AC_SUBST(AR)
AC_SUBST(RANLIB)
AC_SUBST(MPI_INCLUDE_DIR)
AC_SUBST(MPI_LIB)
AC_SUBST(F77)
AC_SUBST(NOF77)
AC_SUBST(NOPROFILE)
AC_SUBST(MAKE)
AC_SUBST(arch_IRIX)
AC_SUBST(ROMIO_HOME)
AC_SUBST(LIBNAME)
AC_SUBST(TEST_LIBNAME)
AC_SUBST(LL)
AC_SUBST(F77GETARG)
AC_SUBST(F77IARGC)
AC_SUBST(F77MPIOINC)
AC_SUBST(FTESTDEFINE)
AC_SUBST(FORTRAN_MPI_OFFSET)
AC_SUBST(FROM_MPICH)
AC_SUBST(FROM_MPICH2)
AC_SUBST(FROM_LAM)
AC_SUBST(WITHIN_KNOWN_MPI_IMPL)
AC_SUBST(NEEDS_MPI_FINT)
AC_SUBST(HAVE_MPI_INFO)
AC_SUBST(BUILD_MPI_INFO)
AC_SUBST(HAVE_MPI_DARRAY_SUBARRAY)
AC_SUBST(BUILD_MPI_ARRAY)
AC_SUBST(DEFINE_MPI_OFFSET)
AC_SUBST(DEFINE_HAVE_MPI_GREQUEST)
AC_SUBST(MPI_OFFSET_TYPE)
AC_SUBST(MPI_FINFO1)
AC_SUBST(MPI_FINFO2)
AC_SUBST(MPI_FINFO3)
AC_SUBST(MPI_FINFO4)
AC_SUBST(MPI_FARRAY1)
AC_SUBST(MPI_FARRAY2)
AC_SUBST(MPI_FARRAY3)
AC_SUBST(MPI_FARRAY4)
AC_SUBST(MPI_FARRAY5)
AC_SUBST(MPI_FARRAY6)
AC_SUBST(MPI_FARRAY7)
AC_SUBST(MPI_OFFSET_KIND1)
AC_SUBST(MPI_OFFSET_KIND2)
AC_SUBST(MPIO_REQOBJECTS)
AC_SUBST(TEST_CC)
AC_SUBST(TEST_F77)
AC_SUBST(ROMIO_INCLUDE)
AC_SUBST(ROMIO_LFLAGS)
AC_SUBST(ROMIO_LIBLIST)
AC_SUBST(ROMIO_TCFLAGS)
AC_SUBST(ROMIO_TCPPFLAGS)
AC_SUBST(ROMIO_TFFLAGS)
AC_SUBST(MPIRUN)
AC_SUBST(FORTRAN_TEST)
dnl
dnl Dependency handling
AC_SUBST(MAKE_DEPEND_C)
dnl
dnl Support shared libraries
if test -z "$ENABLE_SHLIB" ; then
   ENABLE_SHLIB=none
fi
AC_SUBST(ENABLE_SHLIB)
AC_SUBST(CC_SHL)
AC_SUBST(LIBTOOL)
# Remove the .a from the library file name (so that we can use .so or
# other appropriate suffix)
SHLIBNAME=`echo $LIBNAME | sed 's/\.a//'`
AC_SUBST(SHLIBNAME)
dnl
if test ! -d adio ; then mkdir adio ; fi
if test ! -d adio/include ; then mkdir adio/include ; fi
if test ! -d mpi2-other ; then mkdir mpi2-other ; fi
if test ! -d mpi-io ; then mkdir mpi-io ; fi
if test ! -d mpi-io/glue ; then mkdir mpi-io/glue ; fi
# 
# Make sure we remove any configuration file incase there is out-of-date data.
# We remove the version in include in case this is a vpath build
rm -f adio/include/romioconf.h ${use_top_srcdir}/src/mpi/romio/adio/include/romioconf.h ${use_top_srcdir}/adio/include/romioconf.h
#
# Create makefiles for all of the adio devices.  Only the ones that 
# are active will be called by the top level ROMIO make
AC_OUTPUT_COMMANDS([chmod 755 util/romioinstall test/runtests])
AC_OUTPUT(Makefile localdefs mpi-io/Makefile mpi2-other/info/Makefile \
		   mpi2-other/array/Makefile adio/common/Makefile \
		   test/Makefile test/misc.c test/large_file.c \
		   test/runtests util/romioinstall include/mpio.h \
		   include/mpiof.h \
		   adio/ad_nfs/Makefile adio/ad_ufs/Makefile \
		   adio/ad_panfs/Makefile \
		   adio/ad_xfs/Makefile \
		   adio/ad_sfs/Makefile adio/ad_pfs/Makefile \
		   adio/ad_testfs/Makefile adio/ad_pvfs/Makefile \
		   adio/ad_pvfs2/Makefile \
		   adio/ad_gridftp/Makefile \
                   mpi-io/fortran/Makefile mpi2-other/info/fortran/Makefile \
                   mpi2-other/array/fortran/Makefile test/fmisc.f \
                   test/fcoll_test.f test/pfcoll_test.f test/fperf.f \
		   mpi-io/glue/mpich2/Makefile \
		   mpi-io/glue/mpich1/Makefile \
		   mpi-io/glue/default/Makefile )
#
rm -f *.o

if test $FROM_MPICH = no -a $FROM_MPICH2 = no ; then
   AC_MSG_RESULT([Configure done. Now type make.])
fi
dnl PAC_SUBDIR_CACHE_CLEANUP
exit 0
