#!/usr/bin/expect
############################################################################
# Purpose: Test of SLURM functionality
#          sacctmgr load data file
#          
#
# Output:  "TEST: #.#" followed by "SUCCESS" if test was successful, OR
#          "FAILURE: ..." otherwise with an explanation of the failure, OR
#          anything else indicates a failure mode that must be investigated.
############################################################################
# Copyright (C) 2008 Lawrence Livermore National Security.
# Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
# Written by Joseph Donaghy <donaghy1@llnl.gov>
# LLNL-CODE-402394.
# 
# This file is part of SLURM, a resource management program.
# For details, see <http://www.llnl.gov/linux/slurm/>.
#  
# SLURM is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
# 
# SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along
# with SLURM; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
############################################################################
source ./globals

set test_id     "21.22"
set test_acct   "test_acct"
set exit_code   0
set file_in     "test$test_id.input"
set file_in2    "test$test_id.input2"
set file_in3    "test$test_id.input3"
set file_out    "test$test_id.output"
set file_out2   "test$test_id.output2"
set file_out3   "test$test_id.output3"
set lis		list
set as		assoc
set fmt		format
set cln		clean
set tre		tree
set was		withassoc
set wco		withcoordinator
set par		Parent
set roo		root
set clu		Cluster
set cl1		clust1
set acc		Account
set nams	names
set nm1		scienceacct
set nm2		physicsacct
set nm3		theoryacct
set nm4		appliedacct
set dsc		Description
set ds1		scienceacct
set ds2		physicsacct
set ds3		theoryacct
set ds4		appliedacct
set org		Organization
set or1		scienceorg
set or2		physicsorg
set or3		theoryorg
set or4		appliedorg
set usr		user
set us1		u1ser
set us2		u2ser
set us3		u3ser
set us4		u4ser
set qs		QOS
set qs1		normal
set pat		parent
set al		AdminLevel
set aln		None
set ala		Administrator
set alo		Operator
set coo         Coordinator
set col         CoordinatorList
set dac		DefaultAccount
set pts		Partitions
set pde		pdebug
set pba		pbatch
set fs		Fairshare
set gm		GrpCPUMins
set gc		GrpCPUs
set gj		GrpJobs
set gs		GrpSubmitJobs
set gn		GrpNodes
set gw		GrpWall
set mm		MaxCPUMins
set mc		MaxCPUs
set mj		MaxJobs
set ms		MaxSubmitJobs
set mn		MaxNodes
set mw		MaxWall
set fs1		1000
set fs2		2375
set fs3		3240
set fs4		4321
set fs5		5678
set fs6		6789
set gm1		1100
set gc1		10
set gj1		120
set gs1		130
set gn1		140
set gw1		60
set gt1		01:00:00
set mc1		150
set mm1		110000
set mj1		160
set ms1		170
set mn1		180
set mw1		70
set mt1		01:10:00
set gm2		2000
set gc2		20
set gj2		210
set gs2		220
set gn2		230
set gw2		120
set gt2		02:00:00
set mc2		240
set mm2		220000
set mj2		250
set ms2		260
set mn2		270
set mw2		140
set mt2		02:20:00
set gm3		3300
set gc3		30
set gj3		310
set gs3		320
set gn3		330
set gw3		180
set gt3		03:00:00
set mc3		340
set mm3		330000
set mj3		350
set ms3		360
set mn3		370
set mw3		210
set mt3		03:30:00
set gm4		4000
set gc4		40
set gj4		410
set gs4		420
set gn4		430
set gw4		240
set gt4		04:00:00
set mc4		440
set mm4		420000
set mj4		450
set ms4		460
set mn4		470
set mw4		280
set mt4		04:40:00
set gm5		5500
set gc5		50
set gj5		510
set gs5		520
set gn5		530
set gw5		300
set gt5		05:00:00
set mc5		540
set mm5		550000
set mj5		550
set ms5		560
set mn5		570
set mw5		350
set mt5		05:50:00
set gm6		6600
set gc6		60
set gj6		610
set gs6		620
set gn6		630
set gw6		1440
set gt6		1-00:00:00
set mc6		640
set mm6		660000
set mj6		650
set ms6		660
set mn6		670
set mw6		2880
set mt6		2-00:00:00
set access_err  0

#set user_name   "id -u -n"

print_header $test_id

#
# Check accounting config and bail if not found.
#
if { [test_account_storage] == 0 } {
	send_user "\nWARNING: This test can't be run without a usable AccountStorageType\n"
	exit 0
}

if { [string compare [check_accounting_admin_level] "Administrator"] } {
	send_user "\nWARNING: This test can't be run without being an Accounting administrator.\nUse sacctmgr mod user \$USER_NAME admin=admin.\n"
	exit 0
}

#
# Identify the user and his current default account
#
set acct_name ""
set user_name ""
spawn $bin_id -u -n
expect {
	 -re "($alpha_numeric_under)" {
		set user_name $expect_out(1,string)
		exp_continue
	}
	eof {
		wait
	}
}
set s_pid [spawn $sacctmgr show user $user_name]
expect {
	-re "$user_name *($alpha_numeric_under)" {
		set acct_name $expect_out(1,string)
		exp_continue
	}
	timeout {
		send_user "FAILURE: sacctmgr add not responding\n"
		slow_kill $s_pid
		exit 1
	}
	eof {
		wait
	}
}

#
# Use sacctmgr to add an account
#
set aamatches 0
set sadd_pid [spawn $sacctmgr -i add account $test_acct]
expect {
	-re "Adding Account" {
		incr aamatches
		exp_continue
	}
	-re "Nothing new added" {
		send_user "\nWARNING: vestigial account $test_acct found\n"
		incr aamatches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr add not responding\n"
		slow_kill $sadd_pid
		set exit_code 1
	}
	eof {
		wait
	}
}
if {$aamatches != 1} {
	send_user "\nFAILURE:  sacctmgr had a problem adding account.\n"
	exit 1
}

#
# Add self to this new account
#
set sadd_pid [spawn $sacctmgr -i create user name=$user_name account=$test_acct]
expect {
	 timeout {
		send_user "\nFAILURE: sacctmgr add not responding\n"
		slow_kill $sadd_pid
		set exit_code 1
	}
	eof {
		wait
	}
}

set timeout 60

#
# Delete left-over input script files
#
exec $bin_rm -f $file_in
exec $bin_rm -f $file_in2
exec $bin_rm -f $file_in3

#
# Build input script file - to create original associations
#
exec echo "$clu - $cl1:$fs=$fs6:$gm=$gm6:$gc=$gc6:$gj=$gj6:$gn=$gn6:$gs=$gs6:$gw=$gw6:$mm=$mm6:$mc=$mc6:$mj=$mj6:$mn=$mn6:$ms=$ms6:$mw=$mw6:$qs=$qs1"     >>$file_in
exec echo "$par - $roo"     >>$file_in
exec echo "$acc - $nm1:$dsc=$ds1:$org=$or1:$fs=$fs5:$gm=$gm5:$gc=$gc5:$gj=$gj5:$gn=$gn5:$gs=$gs5:$gw=$gw5:$mm=$mm5:$mc=$mc5:$mj=$mj5:$mn=$mn5:$ms=$ms5:$mw=$mw5:$qs=$qs1"     >>$file_in
exec echo "$acc - $nm2:$dsc=$ds2:$org=$or2:$fs=$fs4:$gm=$gm4:$gc=$gc4:$gj=$gj4:$gn=$gn4:$gs=$gs4:$gw=$gw4:$mm=$mm4:$mc=$mc4:$mj=$mj4:$mn=$mn4:$ms=$ms4:$mw=$mw4:$qs=$qs1"     >>$file_in
exec echo "$par - $nm1"     >>$file_in
exec echo "$acc - $nm3:$dsc=$ds3:$org=$or3:$fs=$fs3:$gm=$gm3:$gc=$gc3:$gj=$gj3:$gn=$gn3:$gs=$gs3:$gw=$gw3:$mm=$mm3:$mc=$mc3:$mj=$mj3:$mn=$mn3:$ms=$ms3:$mw=$mw3:$qs=$qs1"     >>$file_in
exec echo "$par - $nm2"     >>$file_in
exec echo "$usr - $us1:$coo=$nm2:$dac=$nm1:$fs=$fs1:$mm=$mm2:$mc=$mc2:$mj=$mj2:$mn=$mn2:$ms=$ms2:$mw=$mw2:$qs=$qs1:$al=$alo"     >>$file_in
exec echo "$par - $nm3"     >>$file_in
exec echo "$usr - $us2:$coo=$nm3:$dac=$nm2:$fs=$fs2:$mm=$mm1:$mc=$mc1:$mj=$mj1:$mn=$mn1:$ms=$ms1:$mw=$mw1:$qs=$qs1:$al=$ala"     >>$file_in

#
# Second input file - to modify and add associations to the original 
#
exec echo "$clu - $cl1"     >>$file_in2
exec echo "$par - $roo"     >>$file_in2
exec echo "$acc - $nm1"     >>$file_in2
exec echo "$acc - $nm3:$dsc=$ds1:$org=$or1:$fs=$fs5:$gm=$gm5:$gc=$gc5:$gj=$gj5:$gn=$gn5:$gs=$gs5:$gw=$gw5:$mm=$mm5:$mc=$mc5:$mj=$mj5:$mn=$mn5:$ms=$ms5:$mw=$mw5:$qs=$qs1"     >>$file_in2
exec echo "$par - $nm1"     >>$file_in2
exec echo "$acc - $nm2"     >>$file_in2
exec echo "$par - $nm2"     >>$file_in2
exec echo "$usr - $us3:$coo=$nm1,$nm2,$nm3:$dac=$nm1:$fs=$fs2:$mm=$mm2:$mc=$mc2:$mj=$mj2:$mn=$mn2:$ms=$ms2:$mw=$mw2:$qs=$qs1:$al=$ala"     >>$file_in2
exec echo "$par - $nm3"     >>$file_in2
exec echo "$usr - $us2:$dac=$nm1:$fs=$fs3:$mm=$mm3:$mc=$mc3:$mj=$mj3:$mn=$mn3:$ms=$ms3:$mw=$mw3:$qs=$qs1:$al=$alo"     >>$file_in2
exec echo "$usr - $us3:$dac=$nm1:$fs=$fs3:$mm=$mm3:$mc=$mc3:$mj=$mj3:$mn=$mn3:$ms=$ms3:$mw=$mw3:$qs=$qs1"     >>$file_in2
exec echo "$par - $nm1"     >>$file_in2
exec echo "$usr - $us3:$dac=$nm2:$fs=$fs2:$mm=$mm1:$mc=$mc1:$mj=$mj1:$mn=$mn1:$ms=$ms1:$mw=$mw1:$qs=$qs1"     >>$file_in2

#
# Third input file - to replace all previous
#
exec echo "$clu - $cl1:$fs=$fs6:$gm=$gm6:$gc=$gc6:$gj=$gj6:$gn=$gn6:$gs=$gs6:$gw=$gw6:$mm=$mm6:$mc=$mc6:$mj=$mj6:$mn=$mn6:$ms=$ms6:$mw=$mw6:$qs=$qs1"    >>$file_in3
exec echo "$par - $roo"    >>$file_in3
exec echo "$acc - $nm1:$dsc=$ds1:$org=$or1:$fs=$fs5:$gm=$gm5:$gc=$gc5:$gj=$gj5:$gn=$gn5:$gs=$gs5:$gw=$gw5:$mm=$mm5:$mc=$mc5:$mj=$mj5:$mn=$mn5:$ms=$ms5:$mw=$mw5:$qs=$qs1"    >>$file_in3
exec echo "$acc - $nm3:$dsc=$ds3:$org=$or3:$fs=$fs5:$gm=$gm5:$gc=$gc5:$gj=$gj5:$gn=$gn5:$gs=$gs5:$gw=$gw5:$mm=$mm5:$mc=$mc5:$mj=$mj5:$mn=$mn5:$ms=$ms5:$mw=$mw5:$qs=$qs1"    >>$file_in3
exec echo "$par - $nm1"    >>$file_in3
exec echo "$acc - $nm3:$dsc=$ds1:$org=$or1:$fs=$fs5:$gm=$gm5:$gc=$gc5:$gj=$gj5:$gn=$gn5:$gs=$gs5:$gw=$gw5:$mm=$mm5:$mc=$mc5:$mj=$mj5:$mn=$mn5:$ms=$ms5:$mw=$mw5:$qs=$qs1"    >>$file_in3
exec echo "$acc - $nm2:$dsc=$ds2:$org=$or2:$fs=$fs4:$gm=$gm4:$gc=$gc4:$gj=$gj4:$gn=$gn4:$gs=$gs4:$gw=$gw4:$mm=$mm4:$mc=$mc4:$mj=$mj4:$mn=$mn4:$ms=$ms4:$mw=$mw4:$qs=$qs1:$al=$alo"    >>$file_in3
exec echo "$usr - $us3:$coo=$nm1,$nm2,$nm3:$dac=$nm2:$fs=$fs2:$mm=$mm1:$mc=$mc1:$mj=$mj1:$mn=$mn1:$ms=$ms1:$mw=$mw1:$qs=$qs1:$al=$ala"     >>$file_in3
exec echo "$par - $nm2"    >>$file_in3
exec echo "$usr - $us1:$coo=$nm2:$dac=$nm1:$fs=$fs1:$mm=$mm2:$mc=$mc2:$mj=$mj2:$mn=$mn2:$ms=$ms2:$mw=$mw2:$qs=$qs1:$al=$alo"    >>$file_in3
exec echo "$usr - $us3:$dac=$nm1:$fs=$fs2:$mm=$mm2:$mc=$mc2:$mj=$mj2:$mn=$mn2:$ms=$ms2:$mw=$mw2:$qs=$qs1"    >>$file_in3
exec echo "$par - $nm3"    >>$file_in3
exec echo "$usr - $us2:$coo=$nm3:$dac=$nm1:$fs=$fs3:$mm=$mm3:$mc=$mc3:$mj=$mj3:$mn=$mn3:$ms=$ms3:$mw=$mw3:$qs=$qs1"    >>$file_in3
exec echo "$usr - $us3:$dac=$nm1:$fs=$fs3:$mm=$mm3:$mc=$mc3:$mj=$mj3:$mn=$mn3:$ms=$ms3:$mw=$mw3:$qs=$qs1"    >>$file_in3

#
# Check accounting config and bail if not found.
#
if { [test_account_storage] == 0 } {
	send_user "\nWARNING: This test can't be run without a usable AccountStorageType\n"
	exit 0
}

if { [string compare [check_accounting_admin_level] "Administrator"] } {
	send_user "\nWARNING: This test can't be run without being an Accounting administrator.\nUse sacctmgr mod user \$USER_NAME admin=admin.\n"
	exit 0
}


#
# Use sacctmgr to remove the test cluster
#
proc _remove_cluster {name} {
        global access_err sacctmgr timeout

	set exit_code 0
	set matches 0
	set nothing 0

	if { ![string length $name] } {
		send_user "FAILURE: we need a name to remove\n"
		return 1
	}

	set my_pid [spawn $sacctmgr -i delete cluster $name]
	expect {
		-re "privilege to perform this action" {
			set access_err 1
			exp_continue
		}
		-re "(There was a problem|Unknown condition|Bad format on|Bad MaxWall|Unknown option)" {
			send_user "FAILURE: there was a problem with the sacctmgr command\n"
			incr exit_code 1
		}
		-re "Problem getting" {
			send_user "FAILURE: there was a problem getting information from the database\n"
			incr exit_code 1
		}
		-re "Problem adding" {
			send_user "FAILURE: there was an unknwon problem\n"
			incr exit_code 1
		}
		-re "No associations" {
			send_user "FAILURE: your command didn't return anything\n"
			incr exit_code 1
		}
		-re "Deleting clusters" {
			incr matches
			exp_continue
		}
		-re " Nothing deleted" {
			incr matches
			set nothing 1
			exp_continue
		}
		timeout {
			send_user "\nFAILURE: sacctmgr delete not responding\n"
			slow_kill $my_pid
			incr exit_code 1
		}
		eof {
			wait
		}
	}
	if {$access_err != 0} {
		return 1
	}
	if {$matches != 1} {
		send_user "\nFAILURE: sacctmgr had a problem deleting cluster got $matches\n"
		incr exit_code 1
	}
	if { !$nothing } {
		if { ![check_acct_associations] } {
			send_user "\nFAILURE:  Our associations don't line up\n"
			incr exit_code 1
		}
	}

	return $exit_code
}

#
# Use sacctmgr to remove an account
#
proc _remove_acct { cluster name } {
        global sacctmgr timeout

	set exit_code 0
	set matches 0
	set nothing 1
	set check "Deleting account"

	if { ![string length $name] } {
		send_user "FAILURE: we need a name to remove\n"
		return 1
	}

	set command "$name"

	if { [string length $cluster] } {
		set command "$command cluster=$cluster"
		set check "Deleting account associations"
	}

	set my_pid [eval spawn $sacctmgr -i delete account $command]
	expect {
		-re "(There was a problem|Unknown condition|Bad format on|Bad MaxWall|Unknown option)" {
			send_user "FAILURE: there was a problem with the sacctmgr command\n"
			incr exit_code 1
		}
		-re "Problem getting" {
			send_user "FAILURE: there was a problem getting information from the database\n"
			incr exit_code 1
		}
		-re "Problem adding" {
			send_user "FAILURE: there was an unknwon problem\n"
			incr exit_code 1
		}
		-re "No associations" {
			send_user "FAILURE: your command didn't return anything\n"
			incr exit_code 1
		}
		-re "$check" {
			incr matches
			exp_continue
		}
		-re " Nothing deleted" {
			incr matches
			set nothing 1
			exp_continue
		}
		timeout {
			send_user "\nFAILURE: sacctmgr add not responding\n"
			slow_kill $my_pid
			incr exit_code 1
		}
		eof {
			wait
		}
	}

	if {$matches != 1} {
		send_user "\nFAILURE:  sacctmgr had a problem deleting account.
	got $matches\n"
		incr exit_code 1
	}

	if { !$nothing } {
		if { ![check_acct_associations] } {
			send_user "\nFAILURE:  Our associations don't line up\n"
			incr exit_code 1
		}
	}

	return $exit_code
}

#
# Use sacctmgr to remove an user
#
proc _remove_user { acct user } {
        global sacctmgr timeout

	set exit_code 0
	set matches 0
	set nothing 1
	set check "Deleting user"

	if { ![string length $user] } {
		send_user "FAILURE: we need a name to remove\n"
		return 1
	}

	set command "$user"

	if { [string length $acct] } {
		set command "$command account=$acct"
		set check "Deleting user associations"
	}

	set my_pid [eval spawn $sacctmgr -i delete user $command]
	expect {
		-re "(There was a problem|Unknown condition|Bad format on|Bad MaxWall|Unknown option)" {
			send_user "FAILURE: there was a problem with the sacctmgr command\n"
			incr exit_code 1
		}
		-re "Problem getting" {
			send_user "FAILURE: there was a problem getting information from the database\n"
			incr exit_code 1
		}
		-re "Problem adding" {
			send_user "FAILURE: there was an unknown problem\n"
			incr exit_code 1
		}
		-re "No associations" {
			send_user "FAILURE: your command didn't return anything\n"
			incr exit_code 1
		}
		-re "$check" {
			incr matches
			exp_continue
		}
		-re " Nothing deleted" {
			incr matches
			set nothing 1
			exp_continue
		}
		timeout {
			send_user "\nFAILURE: sacctmgr delete not responding\n"
			slow_kill $my_pid
			incr exit_code 1
		}
		eof {
			wait
		}
	}

	if {$matches != 1} {
		send_user "\nFAILURE:  sacctmgr had a problem deleting user.
	got $matches\n"
		incr exit_code 1
	}

	if { !$nothing } {
		if { ![check_acct_associations] } {
			send_user "\nFAILURE:  Our associations don't line up\n"
			incr exit_code 1
		}
	}

	return $exit_code
}

#make sure we have a clean system and permission to do this work
_remove_user "" "$us1,$us2,$us3"
_remove_acct "" "$nm1,$nm2,$nm3"
_remove_cluster "$cl1"
if {$access_err != 0} {
	send_user "\nWARNING: not authorized to perform this test\n"
	exit $exit_code
}

set matches 0
set my_pid [spawn $sacctmgr -i load $file_in]
expect {
	-re "(Unable to read *.* * No such file or directory)" {
	        send_user "FAILURE: there was a problem with the file\n"
	    	incr exit_code 1
	}
	-re "error" {
	        send_user "FAILURE: there was a problem with the file\n"
	    	incr exit_code 1
	}
	-re "Problem with requests" {
	        send_user "FAILURE: there was a problem with the request\n"
	    	incr exit_code 1
	}
	-re "(sacctmgr: For cluster $cl1)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 1} {
	send_user "\nFAILURE:  File load 1 incorrect with only $matches.\n"
	incr exit_code 1
}

#
# Use sacctmgr to list the test original association additions
#
set matches 0
set my_pid [spawn $sacctmgr -n -p $lis $as $clu=$cl1 $fmt=$clu,$acc,$usr,$pts,$fs,$gm,$gc,$gj,$gn,$gs,$gw,$mc,$mm,$mj,$mn,$ms,$mw,$qs]
expect {
	-re "There was a problem" {
	        send_user "FAILURE: there was a problem with the sacctmgr command\n"
	    	incr exit_code 1
	}
	-re "($cl1.$roo...$fs6.$gm6.$gc6.$gj6.$gn6.$gs6.$gt6.$mc6.$mm6.$mj6.$mn6.$ms6.$mt6.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$roo.$roo..1.......$mc6.$mm6.$mj6.$mn6.$ms6.$mt6.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm2...$fs4.$gm4.$gc4.$gj4.$gn4.$gs4.$gt4.$mc4.$mm4.$mj4.$mn4.$ms4.$mt4.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm2.$us1..$fs1.......$mc2.$mm2.$mj2.$mn2.$ms2.$mt2.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm1...$fs5.$gm5.$gc5.$gj5.$gn5.$gs5.$gt5.$mc5.$mm5.$mj5.$mn5.$ms5.$mt5.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm3...$fs3.$gm3.$gc3.$gj3.$gn3.$gs3.$gt3.$mc3.$mm3.$mj3.$mn3.$ms3.$mt3.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm3.$us2..$fs2.......$mc1.$mm1.$mj1.$mn1.$ms1.$mt1.$qs1)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 7} {
	send_user "\nFAILURE:  Associations addition 1 incorrect with only $matches.\n"
	incr exit_code 1
}

#
# Use sacctmgr to list the test original Admin Levels and Account Coordinators
#
set matches 0
set my_pid [spawn $sacctmgr -n -p $lis $usr $fmt=$usr,$col,$ala $wco]
expect {
	-re "There was a problem" {
	        send_user "FAILURE: there was a problem with the sacctmgr command\n"
	    	incr exit_code 1
	}
	-re "($us1.$nm2.$alo)" {
		incr matches
		exp_continue
	}
	-re "($us2.$nm3.$ala)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 2} {
	send_user "\nFAILURE:  Adminstrator and coordinator 1 incorrect with only $matches.\n"
	incr exit_code 1
}

set matches 0
set my_pid [spawn $sacctmgr -i load $file_in2]
expect {
	-re "(Unable to read *.* * No such file or directory)" {
	        send_user "FAILURE: there was a problem with the file\n"
	    	incr exit_code 1
	}
	-re "error" {
	        send_user "FAILURE: there was a problem with the file\n"
	    	incr exit_code 1
	}
	-re "Problem with requests" {
	        send_user "FAILURE: there was a problem with the request\n"
	    	incr exit_code 1
	}
	-re "(sacctmgr: For cluster $cl1)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 1} {
	send_user "\nFAILURE:  File load 1 incorrect with only $matches.\n"
	incr exit_code 1
}

#
# Use sacctmgr to list the test modifications to the original association
#
set matches 0
set my_pid [spawn $sacctmgr -n -p $lis $as $clu=$cl1 $fmt=$clu,$acc,$usr,$pts,$fs,$gm,$gc,$gj,$gn,$gs,$gw,$mc,$mm,$mj,$mn,$ms,$mw,$qs]
expect {
	-re "There was a problem" {
	        send_user "FAILURE: there was a problem with the sacctmgr command\n"
	    	incr exit_code 1
	}
	-re "($cl1.$roo...$fs6.$gm6.$gc6.$gj6.$gn6.$gs6.$gt6.$mc6.$mm6.$mj6.$mn6.$ms6.$mt6.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$roo.$roo..1.......$mc6.$mm6.$mj6.$mn6.$ms6.$mt6.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm1...$fs5.$gm5.$gc5.$gj5.$gn5.$gs5.$gt5.$mc5.$mm5.$mj5.$mn5.$ms5.$mt5.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm1.$us3..$fs2.......$mc1.$mm1.$mj1.$mn1.$ms1.$mt1.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm2...$fs4.$gm4.$gc4.$gj4.$gn4.$gs4.$gt4.$mc4.$mm4.$mj4.$mn4.$ms4.$mt4.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm2.$us1..$fs1.......$mc2.$mm2.$mj2.$mn2.$ms2.$mt2.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm2.$us3..$fs2.......$mc2.$mm2.$mj2.$mn2.$ms2.$mt2.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm3...$fs5.$gm5.$gc5.$gj5.$gn5.$gs5.$gt5.$mc5.$mm5.$mj5.$mn5.$ms5.$mt5.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm3.$us2..$fs3.......$mc3.$mm3.$mj3.$mn3.$ms3.$mt3.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm3.$us3..$fs3.......$mc3.$mm3.$mj3.$mn3.$ms3.$mt3.$qs1)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 10} {
	send_user "\nFAILURE:  Association modification 1 incorrect with only $matches.\n"
	incr exit_code 1
}

#
# Use sacctmgr to list the test modification Admin Levels and Account Coordinators
#
set matches 0
set my_pid [spawn $sacctmgr -n -p $lis $usr $fmt=$usr,$col,$ala $wco]
expect {
	-re "There was a problem" {
	        send_user "FAILURE: there was a problem with the sacctmgr command\n"
	    	incr exit_code 1
	}
	-re "($us1.$nm2.$alo)" {
		incr matches
		exp_continue
	}
	-re "($us2.$nm3.$alo)" {
		incr matches
		exp_continue
	}
	-re "($us3.$nm2,$nm1,$nm3.$ala)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 3} {
	send_user "\nFAILURE:  Adminstrator and coordinator 1 incorrect with only $matches.\n"
	incr exit_code 1
}

set matches 0
set my_pid [spawn $sacctmgr -i load  $file_in3 clean]
expect {
	-re "(Unable to read *.* * No such file or directory)" {
	        send_user "FAILURE: there was a problem with the file\n"
	    	incr exit_code 1
	}
	-re "error" {
	        send_user "FAILURE: there was a problem with the file\n"
	    	incr exit_code 1
	}
	-re "Problem with requests" {
	        send_user "FAILURE: there was a problem with the request\n"
	    	incr exit_code 1
	}
	-re "(sacctmgr: For cluster $cl1)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 1} {
	send_user "\nFAILURE:  File load 1 incorrect with only $matches.\n"
	incr exit_code 1
}


#
# Use sacctmgr to list the test modifications to the original association
#
set matches 0
set my_pid [spawn $sacctmgr -n -p $lis $as $clu=$cl1 $fmt=$clu,$acc,$usr,$pts,$fs,$gm,$gc,$gj,$gn,$gs,$gw,$mc,$mm,$mj,$mn,$ms,$mw,$qs]
expect {
	-re "There was a problem" {
	        send_user "FAILURE: there was a problem with the sacctmgr command\n"
	    	incr exit_code 1
	}
	-re "($cl1.$roo...$fs6.$gm6.$gc6.$gj6.$gn6.$gs6.$gt6.$mc6.$mm6.$mj6.$mn6.$ms6.$mt6.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$roo.$roo..1.......$mc6.$mm6.$mj6.$mn6.$ms6.$mt6.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm1...$fs5.$gm5.$gc5.$gj5.$gn5.$gs5.$gt5.$mc5.$mm5.$mj5.$mn5.$ms5.$mt5.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm1.$us3..$fs2.......$mc1.$mm1.$mj1.$mn1.$ms1.$mt1.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm2...$fs4.$gm4.$gc4.$gj4.$gn4.$gs4.$gt4.$mc4.$mm4.$mj4.$mn4.$ms4.$mt4.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm2.$us1..$fs1.......$mc2.$mm2.$mj2.$mn2.$ms2.$mt2.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm2.$us3..$fs2.......$mc2.$mm2.$mj2.$mn2.$ms2.$mt2.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm3...$fs5.$gm5.$gc5.$gj5.$gn5.$gs5.$gt5.$mc5.$mm5.$mj5.$mn5.$ms5.$mt5.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm3.$us2..$fs3.......$mc3.$mm3.$mj3.$mn3.$ms3.$mt3.$qs1)" {
		incr matches
		exp_continue
	}
	-re "($cl1.$nm3.$us3..$fs3.......$mc3.$mm3.$mj3.$mn3.$ms3.$mt3.$qs1)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 10} {
	send_user "\nFAILURE:  Clean association addition 1 incorrect with only $matches.\n"
	incr exit_code 1
}

#
# Use sacctmgr to list the test modification Admin Levels and Account Coordinators
#
set matches 0
set my_pid [spawn $sacctmgr -n -p $lis $usr $fmt=$usr,$col,$ala $wco]
expect {
	-re "There was a problem" {
	        send_user "FAILURE: there was a problem with the sacctmgr command\n"
	    	incr exit_code 1
	}
	-re "($us1.$nm2.$alo)" {
		incr matches
		exp_continue
	}
	-re "($us2.$nm3.$alo)" {
		incr matches
		exp_continue
	}
	-re "($us3.$nm2,$nm1,$nm3.$ala)" {
		incr matches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr list associations not responding\n"
		slow_kill $my_pid
		incr exit_code 1
	}
	eof {
		wait
	}
}

if {$matches != 3} {
	send_user "\nFAILURE:  Adminstrator and coordinator 1 incorrect with only $matches.\n"
	incr exit_code 1
}

# This is the end below here

incr exit_code [_remove_user "" "$us1,$us2,$us3"]
incr exit_code [_remove_acct "" "$nm1,$nm2,$nm3"]
incr exit_code [_remove_cluster "$cl1"]

#
# Use sacctmgr to delete the test account
#
set damatches 0
set sadel_pid [spawn $sacctmgr -i delete account $test_acct]
expect {
	-re "Deleting account" {
		incr damatches
		exp_continue
	}
	timeout {
		send_user "\nFAILURE: sacctmgr delete not responding\n"
		slow_kill $sadel_pid
		set exit_code 1
	}
	eof {
		wait
	}
}
if {$damatches != 1} {
	send_user "\nFAILURE: sacctmgr had a problem deleting account\n"
	set exit_code 1
}

if {$exit_code == 0} {
	send_user "\nSUCCESS\n"
} else {
	send_user "\nFAILURE\n"
}
exit $exit_code

